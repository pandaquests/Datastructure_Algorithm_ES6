\documentclass{book}
\usepackage{blindtext}
\usepackage{scrlfile}
% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, undefined, catch, switch, var, let, const, if, in, while, do, else, case, break, push, pop, shift, unshift},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
}

\usepackage{amsthm}
\usepackage[framemethod=tikz]{mdframed}
\usepackage[most]{tcolorbox}
\usepackage{lipsum}% just to generate text for the example

\newmdtheoremenv[
hidealllines=true,
leftline=true,
innertopmargin=0pt,
innerbottommargin=0pt,
linewidth=4pt,
linecolor=gray!40,
innerrightmargin=0pt,
innertopmargin=-6pt,
]{examplei}{Aufgabe}

\newtcolorbox{exampleii}{
	freelance,
	breakable,
	width=\dimexpr\textwidth+28pt\relax,
	before=\par\vspace{\bigskipamount}\noindent,
	enlarge left by=-14pt,
	overlay unbroken and first={
		\node[
		anchor=north east,
		inner xsep=8pt,
		xshift=8pt,
		rounded corners=5pt,
		font=\bfseries,
		fill=white] at ([xshift=-0.2cm]frame.north west) (tit) {\strut Example:};
		\draw[
		line width=3pt,
		rounded corners=5pt,gray
		] ([xshift=4pt]frame.north west) -- ([xshift=4pt]frame.south west);
	},
	overlay middle and last={
		\draw[
		line width=3pt,
		rounded corners=5pt,gray
		] ([xshift=4pt]frame.north west) -- ([xshift=4pt]frame.south west);
	},
	frame code={},
	interior code={},
	top=0pt,
	bottom=0pt
}

\renewcommand{\contentsname}{Inhalt}
\renewcommand{\chaptername}{Kapitel}

\begin{document}
\tableofcontents
%\blinddocument
\chapter{Algorithmen und Datenstrukturen in ES6+}

Dieses Buch ist noch in Bearbeitung....
\section{Warum in ES6+}
- ES is eating the world

- meaningful understanding

- I spent most of my professional life writing in JS and I think I know most about it

\section{Nicht behandelte Themen}
- Promises
- async/await
- webAPI
- Browser spezifische Unterschiede

\chapter{Entwicklungsumgebung}
JS ist eine interpretierte Sprache. Sie läuft auf einer JS Engine. Die JS Engine läuft auf jeden Browser. Man kann direkt im Browser den Code ausführen.

Sobald man den Browser aber neu lädt ist unser Code weg. Besser ist es den Code entweder in nodejs auszuführen.

File speichern und mit node [filename] ausführen
\chapter{JavaScript Paradigmen}
JS ist eine sog. Multiparadigmen Programmiersprache. JS ist imperativ, objektorientiert und funktional. 
\section{Object-Orientiertes Programmieren}
\section{Funktionales Programmieren}
\chapter{JavaScript Konstrukte}
\section{Entscheidungskonstrukte}
In JS gibt es if Statements, ternary und switch statement.
if
if else
if else if 
ternary operator

Return 

statement vs. expression
switch

\section{Wiederholungen}
for loop, while loop, do while loop, symbol iterator; Generator; yields, for of 

\section{Funktionen}
\section{Scope}
\section{Closures}
\section{Call by Reference vs. Call by Value}
\section{Truthy und falsy}

\chapter{Datenstrukturen}
\section{Array}
JS hat im Vergleich zu Java oder C/C++ nur sehr wenige Datenstrukturen. Eines ihrer wichtigsten Datenstrukturen ist der Array. Das Array werden wir später dazu benutzen, um alle anderen komplexeren Datenstrukturen zu implementieren. Der Unterschied zu JSs Arrays im Vergleich zu anderen Programmiersprachen ist, dass Arrays in JS keine fixe Länge haben. Durch das Hinzufügen und Entfernen von Elementen verändert sich die Array-Länge dynamisch mit. Bei der Initialisierung muss man dem Array dadurch auch keine bestimmte Länge mitgeben werden.

Arrays können in JS auf zwei Arten erstellt werden: Mit dem Array Konstruktor oder mit Array Literal:
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayConstructor = new Array();
var myArrayLiteral = [];
\end{lstlisting}

Der Array Konstruktur wird mit \lstinline|new| eingeleitet und darauf folgt \lstinline|Array()|. Beim Array Literal wird nur eine eckige Klammer \lstinline|[]| benötigt. Beide Möglichkeiten erstellen einen Array. Jedoch wird angeraten zur Erstellung eines Arrays das Array Literal zu nehmen. Nicht nur ist er kürzer und auch schneller, er ist auch syntaktisch eindeutiger. Denn mit dem Array Konstruktur kann man auch die Länge des Arrays definieren als auch initialisieren. Die Syntax von beiden Konstrukten sind sich ähnlich, sodass es zu Verwirrung kommen kann, wenn man den Array mit Zahlen initialisiert:

\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
var myArrayInit = new Array(3,2,1);
\end{lstlisting}

Die Länge eines Arrays wird als Zahl (hier: 3) in den Konstruktur reingeschrieben. Damit hat das Array in unserem Beispiel eine Länge von 3, die man mit \lstinline|length| überprüfen kann. Die (hier 3) Elemente sind noch \lstinline|undefined|, da sie noch nicht initialisiert sind. Bei der Initialisierung gibt man die Elemente ebenfalls in den Konstruktur mit ein, jeweils getrennt durch einen Komma. 
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
console.log(myArrayLength); 
// [undefined, undefined, undefined]
console.log(myArrayLenth.length); 
// 3

var myArrayInit = new Array(3,2,1);
console.log(myArrayInit); 
// [3, 2, 1]
console.log(myArrayInit.length); 
// 3
\end{lstlisting}

JS ist nicht static typed. D.h. ein Array kann Elemente nicht nur eines Typen gleichzeitig aufnehmen, sondern auch verschiedene. Ein Array in JS kann damit auch Zahlen, Strings, Bool und Objekte gleichzeitig aufnehmen:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
\end{lstlisting}

Intern werden die Elemente in einen String gecastet. Dadurch sind Arrays in JS langsamer als in anderen Sprachen. Um auf ein Array-Element zuzugreifen benutzen wir die eckige Klammer \lstinline|[]|. Ein Array ist Index basiert und fängt mit \lstinline|0| an. Um auf das zweite Element in einen Array zuzugreifen, schreiben wir also \lstinline|myArray[1]|:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
console.log(myArray[1]);
// "42"
\end{lstlisting}

JS bieten viele Funktionen zur Manipulationen von Arrays an.
Zum Hinzufügen am Ende wird \lstinline|push()| benutzt. Um ein Element am Anfang des Arrays hinzuzufügen, wird \lstinline|unshift()| verwendet:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
myArray.push(4);
console.log(myArray); 
// [1, 2, 3, 4]

myArray.unshift(0);
console.log(myArray); 
// [0, 1, 2, 3, 4]
\end{lstlisting}

Für das Entfernen am Ende des Arrays gibt es \lstinline|pop()|. Die Funktion \lstinline|pop()| entfernt das letzte Element und gibt das entfernte Element zurück. Für das Entfernen am Anfang des Arrays verwendet man \lstinline|shift()|. 

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [0, 1, 2, 3, 4];
console.log(myArray.pop());
// 4
console.log(myArray); 
// [0, 1, 2, 3]

console.log(myArray.shift());
// 0
console.log(myArray); 
// [1, 2, 3]
\end{lstlisting}

Um Elemente hinzuzufügen, zu ersetzen oder zu entfernen, die sich in der Mitte des Arrays befinden, verwendet man \lstinline|splice()|. \lstinline|splice()| nimmt als ersten Parameter den Index, an den das neue Element man hinzufügen will. Als zweiten Parameter wieviele Elemente danach ersetzt wird. Alle darauffolgenden Paramter die hinzuzufügenden Elemente.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 3, 4];
myArray.splice(1,0,2); 
// adds a new element, 2, at index 1

myArray.splice(3,0,5,6,7); 
// adds new elements, 5,6, and 7, at index 3

myArray.splice(5, 1); 
// removes one element at index 5

myArray.splice(2, 3); 
// removes 3 elements starting at index 2

myArray.splice(3, 1, 99); 
// replaces one element at index 3 with the new element 99

myArray.splice(3, 2, 42); 
// replaces 2 elements starting at index 3 with the new element 42

myArray.splice(999,0,2); 
// if the index (first parameter) is larger than the array length, then it will just adds a new element to the end
\end{lstlisting}

Die Elemente in einen Array kann man mit \lstinline|sort()| sortieren. \lstinline|sort()| nimmt eine Methode auf, die zwei Elemente miteinander vergleicht und entweder eine positive oder negative Zahl zurückgibt oder \lstinline|0|. Eine negative Zahl steht dafür, dass die Zahl kleiner ist. Eine positive Zahl steht dafür, dass die Zahl größer ist. Eine \lstinline|0| steht dafür, dass beide Zahlen gleich sind.

Beim Sortieren von Strings ist keine Funktion notwendig. Jedoch kann man eine mitgeben bei der überprüft wird, ob ein String größer ist als ein anderer String. Wenn man jedoch bei der Sortierung von Zahlen sich auf die Default \lstinline|sort()| Funktion verlässt, dann können die Zahlen falsch sortiert werden:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b);
console.log(myArray);
// [1, 4, 5, 8, 1001]

var myArray = [1, 5, 1001, 8, 4];
myArray.sort();
console.log(myArray);
// [1, 1001, 4, 5, 8]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort();
console.log(myArray);
// ["a", "bd", "c", "xxx"]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => a > b ? 1 : -1);
console.log(myArray);
// ["a", "bd", "c", "xxx"]
\end{lstlisting}

Man kann die \lstinline|sort()| Methode auch benutzen, um ein Array absteigend zu sortieren. Dazu kehrt man das Vorzeichen der mitzugebenden Funktion um:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => b - a);
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => (a > b ? -1 : 1));
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Alternativ kann man zur Umkehrung des Arrays auch die \lstinline|reverse()| Funktion benutzen. Diese ist sogar etwas schneller als nur die Sort Funktion mit der Methode und dem umgekehrten Vorzeichen von oben zu benutzen.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b).reverse();
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort().reverse();
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Die Funktionen \lstinline|push(), unshift(), pop(), shift(), splice()|, usw. verändern den originären Array. Es gibt auch Funktionen, die das Original nicht ändert, sondern stattdessen einen neuen Array zurückliefert.

Die \lstinline|map()| Methode geht durch die Elemente durch und wendet dabei eine ihr mitgegebene Methode \lstinline|(currentValue, index, array) => {}| auf jedes einzelne Element im Array an. Die ihr mitgegebene Methode nimmt als erstes Argument das aktuelle Element auf. Das zweite Element ist das momentane Index im Array. Das dritte Argument das ursprüngliche Array. Das Ergebnis ist wieder ein Array mit derselben Länge, wie das ursprüngliche Array:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4];
function multiplyBy2 = item => item * 2;
var doubleArray = myArray.map(multiplyBy2);
console.log(doubleArray);
// [2, 4, 6, 8]
\end{lstlisting}

Die \lstinline|filter()| Methode nimmt ebenfalls eine Funktion als Argument auf und wendet sie auf alle Elemente im Array an. Nur wenn die Auswertung dieser Funktion auf das aktuelle Element \lstinline|truthy| zurückgibt, wird dieses Element auch Teil des später zurückgegebenen Arrays. Die ihr übergebene Methode \lstinline|(currentValue, index, array) => {}| hat als erstes Argument das aktuelle Element. Das zweite Argument ist der aktuelle Index. Das dritte Argument das original Array auf das die \lstinline|filter()| Methode angewendet wird. Nur das erste Argument ist verpflichtend. Die restlichen sind optional. Beispielhaft ist unten die \lstinline|filter()| Methode zum Filtern von nur geraden Zahlen gezeigt:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4, 5, 6];
function isEven = item => item % 2 ;
var onlyEven = myArray.map(isEven);
console.log(onlyEven);
// [2, 4, 6]
\end{lstlisting}

Die \lstinline|reduce()| Methode unterscheidet sich von \lstinline|map()| und \lstinline|filter()| dadurch, dass nicht immer ein Array zurück gegeben werden muss. Stattdessen reduziert die Methode das Array auf einen einzigen Wert. Dieser Wert kann eine Zahl oder auch ein Array sein. Als erstes Argument kann sie eine Methode nehmen. Als zweites Argument nimmt sie einen initial Wert an. Das zweite Argument ist nur optional. Die Methode, die sie aufnimmt, \lstinline|(acc, item, index, array) => {}| hat als erstes Argument einen Akkumulator, der den kumulierten Wert enthält und der am Ende das Ergebnis darstellt. Das zweite Argument ist der aktuelle Wert. Das dritte Argument der Index und das vierte das original Array. Nur die ersten beiden Argumente sind verpflichtend.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var sum = (acc, item) => acc + item;
var sumOfArray = myArray.reduce(sum, 0);
// 6
\end{lstlisting}

Die \lstinline|reduce()| Funktion geht im Array von links nach rechts. Mit der \lstinline|reduceRight()| geht die Funktion von rechts nach links.

Die Methode \lstinline|flat()|\footnote{noch im Experiment Status, d.h. es wurde noch nicht von allen JS Engines implementiert} wird auf Arrays angewendet, die selbst wiederum Arrays enthalten. Sie erstellt ein neues Arrays mit allen Unterarrays. Dabei kann optional bestimmt werden bis zu welcher Ebene die Unterarrays aufgelöst werden. Die \lstinline|flat()| Methode nimmt optional nur einen numerischen Wert an. Dieser legt fest bis zu welcher Ebene die Unterarrays aufgelöst werden.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, [4, 5, 6]];
console.log(myArray.flat());
// [1, 2, 3, 4, 5, 6]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat());
// [1, 2, 3, 4, [5, 6]]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat(2));
// [1, 2, 3, 4, 5, 6]

\end{lstlisting}

Die \lstinline|flat()| Methode wird auch genutzt, um leere Elemente in Arrays zu entfernen
\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, , ,6];
console.log(myArray.flat());
// [1, 2, 3, 6]
\end{lstlisting}

Die Methode \lstinline|flatMap()| \footnote{noch im Experimentier Status, d.h. nicht alle Browser haben es implementiert} ist identisch zum Aufruf einer \lstinline|map()| Methode gefolgt vom Aufruf einer \lstinline|flat()| Methode. Die Methode wendet eine ihr mitgegebene Funktion auf alle Elemente an und flacht sie anschießend ab. Die ihr mitgegebene Funktion \lstinline|(item, index, array) => {}| nimmt als erstes Argument das aktuelle Element. Das zweite Argument der Index und das dritte Argument das Original Array.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var duplicate = item => [item, item];
console.log(myArray.flatMap(duplicate));
// [1, 1, 2, 2, 3, 3]
\end{lstlisting}

Die Funktion \lstinline|concat()| vereint zwei Arrays und liefert das vereinigte Array als neues Array wieder zurück:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray1 = ["a", "b", "c", "x"];
var myArray2 = ["d", "e", "f"];
var newArray = myArray1.concat(myArray2);
console.log(newArray);
// ["a", "b", "c", "x", "d", "e", "f"]
\end{lstlisting}

Eine andere Möglichkeit ist es den Rest/Spread Operator zu verwenden:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray1 = ["a", "b", "c", "x"];
var myArray2 = ["d", "e", "f"];
var newArray = [...myArray1, ...myArray2];
console.log(newArray);
// ["a", "b", "c", "x", "d", "e", "f"]
\end{lstlisting}

Die \lstinline|slice()| Methode erstellt eine (flache) Kopie des Arrays und gibt diese Kopie als neues Array zurück. Die Methode nimmt zwei Argumente auf. Das erste Argument beschreibt ab welchem Index die Kopie erstellt wird. Das zweite optionale Argument beschreibt bis zu welchem (exklusve) Index das Array kopiert wird. Wird für das zweite Argument kein Wert gegeben, dann kopiert er bis zum Arrayende:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArray = myArray.slice(0);
console.log(newArray);
// ["a", "b", "c", "x"]
\end{lstlisting}

Eine flache Kopie deshalb, weil die Funktion die Elemente als Referenz in das neue Array schreibt. D.h. jede Änderung im original Array hat Auswirkung auf das neue Array. Dies gilt jedoch nicht für \lstinline|Number|, \lstinline|String|, \lstinline|boolean|, \lstinline|null|, \lstinline|undefined|, \lstinline|symbol|, sondern für \lstinline|object|, \lstinline|Array|, \lstinline|function|:

\begin{lstlisting}[caption=Array Konstruktor]
// Using slice, create newCar from myCar.
var myHonda = { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } };
var myCar = [myHonda, 2, 'cherry condition', 'purchased 1997'];
var newCar = myCar.slice(0, 2);
console.log(newCar);
// Display the values of myCar, newCar, and the color of myHonda
//  referenced from both arrays.
console.log('myCar[0].color = ' + myCar[0].color);
console.log('newCar[0].color = ' + newCar[0].color);

// Change the color of myHonda.
myHonda.color = 'purple';
console.log('The new color of my Honda is ' + myHonda.color);

// Display the color of myHonda referenced from both arrays.
console.log('myCar[0].color = ' + myCar[0].color);
console.log('newCar[0].color = ' + newCar[0].color);
\end{lstlisting}

Eine weitere Möglichkeit den Array zu kopieren ist mit Hilfe des Rest/Spread-Operators:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArray = [...myArray];
console.log(newArray);
// ["a", "b", "c", "x"]
\end{lstlisting}

Der Unterschied zwischen beiden Möglichkeiten ist, dass \lstinline|slice()| eine flache Kopie und der Rest/Spread Operator eine tiefen Kopie erstellt:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArrayShallow = myArray.slice(0);
var newArrayDeep = [...myArray];
console.log(myArray === newArrayShallow);
// true --> it's pointing to the same memory space

console.log(myArray === newArrayDeep);
// false --> it's pointing to a new memory space
\end{lstlisting}

Es muss aber hier erwähnt werden, dass der Rest/Spread Operator nur eine Ebene tief kopiert. Bei mehrdimensionalen Arrays muss man andere Methoden wählen. Unten sind Methoden aufgelistet mit der man eine tiefen Kopie, also einen Klon, erstellen kann:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];

var clonedArray1 = JSON.parse(JSON.stringify(myArray))
var clonedArray2 = [].concat(myArray);
var clonedArray2 = Array.from(myArray);
\end{lstlisting}

Wie im vorherigen Kapitel angesprochen gibt es die Möglichkeit durch ein Array mit einer Schleife zu iterieren. Die Arrays in JS bieten eigene Funktionen zum Iterieren an. Die \lstinline|forEach()| Funktion nimmt eine Methode und geht durch alle Elemente durch und wendet auf jedes einzelene ELement die Methode an. Die Funktion kann, im Gegensatz zum \lstinline|for|, \lstinline|while|, \lstinline|do while|, usw. Schleifen nicht unterbrochen werden - außer durch das Werfen einer Ausnahme (was aber nicht empfohlen wird). Die \lstinline|forEach()| Funktion liefert kein Ergebnis zurück.

\begin{lstlisting}[caption=Array Konstruktor]

\end{lstlisting}
Will man vorher abbrechen so kann man entweder die \lstinline|every()| oder \lstinline|some()| verwenden. Die \lstinline|every()| nimmt eine Funktion auf und überprüft sie für alle Elemente. Sobald bei der Überprüfung bei eines der Elemente \lstinline|falsy| zurück gegeben wird, bricht sie ab. Bei der \lstinline|some()| wird die Iteration abgebrochen sobald bei der Auswertung \lstinline|truthy| zurückgegeben wird.

\begin{lstlisting}[caption=Array Konstruktor]

\end{lstlisting}

Oft will man ein Element im Array finden. Dazu kann man wieder Schleifen benutzen oder die Built-in Funktionen verwenden. 

Will man nur feststellen, ob ein Element auch im Array vorhanden ist, so kann man \lstinline|includes()| verwenden. Dieses gibt entweder \lstinline|true| oder \lstinline|false| zurück, wenn das Element im Array gefunden bzw. nicht gefunden wurde.

\begin{lstlisting}[caption=Array Konstruktor]

\end{lstlisting}

Eine Möglichkeit herauszufinden, an welcher Position das gesuchte Element sich befindet, bietet \lstinline|indexOf()|. Diese nimmmt eine Funktion auf und liefert den ersten Index des Elements, bei der die mitgegebene Funktion \lstinline|truthy| zurückliefert. \lstinline|lastIndexOf()| macht genau das Gegenteil: sie gibt den Index des zu letzt gefundenen Elements zurück. Falls keines der Elemente den Bedingungen entspricht, liefert \lstinline|indexOf()| und \lstinline|lastIndexOf()| \lstinline|-1| zurück.

\begin{lstlisting}[caption=Array Konstruktor]

\end{lstlisting}

Will man einen \lstinline|String|in einen Array umwandeln, so kann man wieder den Rest/Spread-Operator verwenden. Dabei wird jedes einzelne Zeichen, inklusive Leerzeichen, Komma, Sonderzeichen usw., als eigenes Element in ein neues Array gepackt und zurückgegeben.

\begin{lstlisting}[caption=Array Konstruktor]
var myString = "hello, world";
var myArray = [...myString];
console.log(myArray);
// ["h", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d"]
\end{lstlisting}

Mit \lstinline|split()| kann man festlegen ab wann man die Elemente in einen Array übergeben will. Die Funktion nimmt einen \lstinline|String| als Prädikat auf. Will man z.B. beim obigen Beispiel nur die Wörter in den Array geben, die durch einen Komma getrennt sind, so gibt man das als String in die Funktion ein:
\begin{lstlisting}[caption=Array Konstruktor]
var myString = "hello, world";
var myArray = myString.split(",")
console.log(myArray);
// ["hello", " world"]
\end{lstlisting}

\section{Liste}
Lists are convenient if the order doesn't matter or if you don't have to search for a certain item
implement a fasfwe
listlistSize (property) Number of elements in list
pos (property) Current position in list
length (property) Returns the number of elements in list
clear (function) Clears all elements from list
toString (function) Returns string representation of list
getElement (function) Returns element at current position
insert (function) Inserts new element after existing element
append (function) Adds new element to end of list
remove (function) Removes element from list
front (function) Sets current position to first element of list
end (function) Sets current position to last element of list
prev (function) Moves current position back one element
next (function) Moves current position forward one element
currPos (function) Returns the current position in list
moveTo (function) Moves the current position to specified position

While writing also test your impelmentation with console.assert()
\section{Stack}

\section{Queue}
\section{Dequeue}
\section{Priority Queue}
\section{LinkedList}
\section{Zirkulare LinkedList}
\section{Zweifach verknüpfte LinkedList}
\section{Dictionary}
\section{Hashing}
\section{HashMap}
\section{MapTree}
\section{LinkedMap}
\section{Sets}
\section{Binäre Bäume}
\section{Graphen}
\section{AVL Tree}

\chapter{Algorithmen}
Sortier Algorithmen und Such Algorithmen
\section{Breitensuche}
\section{Tiefensuche}
\section{Bubble Sort}
\section{Selection Sort}
\section{Shellsort}
\section{Mergesort}
\section{Quicksort}
\section{Sequential Suche}
\section{Binäres Suchen}
\section{Suchen nach Minimum und Maximum}
\section{Rucksackproblem}
\section{Greedy Algorithm}
\chapter{übungen}
\section{Binäres Suchen}
\begin{examplei}
Gegeben ist ein Array mit ganzen Zahlen. Gib den Index des gegebenen Keys. Falls kein Ergebnis gefunden wurde, gib \lstinline|-1| zurück.

Beispiel:
Gegeben ist folgender Array, wenn der Key 47 ist, dann soll die Binäre Suche 2 zurückgeben.


	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index     & 0 & 1 & 2 & 3 & 4 & 5  & 6  & 7  & 8  & 9 \\ 
		\hline
		Key & 23 & 31 & 47	  & 65 & 69 & 73 & 75 & 89 & 91 & 93 \\
		\hline
	\end{tabular}

\end{examplei}
{\bf Stichwörter:} Array, Binary Search, Suche
\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item Betrachte das Array von Anfang bis Ende
	\item Berechne den Index der in der Mitte liegt
	\item Wenn der Mitte Index genau auf den Key zeigt, dann gib den diesen Index zurück
	\item Wenn das Element an der Mitte Index kleiner ist als der Key, dann betrachte nur das Subarray von der Mitte Index bis zum Ende
	\item Wenn das Element an der Mitte Index größer ist als der Key, dann betrachte nur das Subarray von der Mitte Index bis zum Anfang
	\item Wiederhole die obigen Schritte solange bis das Subarray leer ist
\end{enumerate}

\paragraph{Typische Fehler}
\begin{lstlisting}[caption=My Javascript Example]
//a is sorted array
let binarySearch = function(a, key) {
	let newA = a;
	let currentIndex;
	while(newA.length !== 0) {
		currentIndex = newA.length / 2;
		const currentKey = newA[currentIndex];
	
		if (currentKey === key) {
			return currentIndex;
		} else if (currentKey < key) {
			newA = newA.slice(currentIndex);
		} else {
			newA = newA.slice(0, currentIndex + 1);
		}
	}
	return -1;
};
\end{lstlisting}

\begin{itemize} 
	\item Ein Array ist index basiert beginned bei 0
	
	Das weißt wahrscheinlich jeder bisher. Jedoch wird die Implikationen dessen sehr oft vergessen. Um auf den Index \lstinline|currentIndex| zu kommen muss die \lstinline|(arr.length - 1) / 2| genommen werden.
	\item Array Index sind immer ganze Zahlen
	
	Auch dies sollte mittlerweile bekannt sein. Doch wie im obigen Fall zu sehen wurde durch \lstinline|2| geteilt. Bei ungeraden Zahlen entstehen dadurch rationale Zahlen, die auf ganze Zahlen wieder zurück gecastet werden müssen
	
	\item Es wird nach dem Index des original Arrays gefragt
	
	Ein neues Array zu erstellen und darauf den Index zu ermitteln bedeutet, dass man den Index des neuen Arrays zurück gibt. Gesucht ist aber der Index des gegebenen Arrays
	\item \lstinline|currentIndex| nicht wiederholt überprüfen
	
	Selbst wenn es möglich sein sollte das original Array in Stücke so zu teilen dass dennoch die original Index beizubehalten, ist die Auswahl der Indexe falsch, denn \lstinline|currentIndex| wurde bereits geprüft. Es ist daher unsinnig, dass dieser Index noch im Subarray erscheint. Man müsste also \lstinline|currentIndex + 1| für \lstinline|currentKey < key| bzw. \lstinline|curentIndex| (\lstinline|currentIndex| selbst wird also nicht betrachtet) für \lstinline|currentKey > key| wählen.
\end{itemize}
\paragraph{Lösung}


\begin{lstlisting}[caption=My Javascript Example]
//a is sorted array
let binarySearch = function(a, key) {
	if (a.length === 0) {
		return -1;
	}
	if (a.length === 1) {
		return a[0] === key ? 0 : -1;
	}
	let startIndex = 0;
	let endIndex = a.length - 1;
	while(startIndex <= endIndex) {
		const currentIndex = (startIndex + endIndex) / 2 | 0;
		const currentKey = a[currentIndex];
		if (currentKey === key) {
			return currentIndex;
		} else if (currentKey < key) {
			startIndex = currentIndex + 1;
		} else {
			endIndex = currentIndex - 1;
		}
	}
	return -1;
};
\end{lstlisting}

\medskip
\begin{lstlisting}[caption=My Javascript Example]
Name.prototype = {
  methodName: function(params){
    var doubleQuoteString = "some text";
    var singleQuoteString = 'some more text';
    // this is a comment
    if(this.confirmed != null && typeof(this.confirmed) == Boolean && this.confirmed == true){
      document.createElement('h3');
      $('#system').append("This looks great");
      return false;
    } else {
      throw new Error;
    }
  }
}
\end{lstlisting}
laskd flwkejf wlekjf ew
\end{document}
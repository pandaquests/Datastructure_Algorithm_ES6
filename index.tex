\documentclass{book}
\usepackage{blindtext}
\usepackage{scrlfile}
% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, undefined, catch, switch, var, let, const, if, in, while, do, else, case, break, push, pop, shift, unshift},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
}
	
	\BeforeClosingMainAux{% siehe KOMA-Script-Anleitung
	\addcontentsline{toc}{part}{Zeichnungen}
	\addcontentsline{toc}{chapter}{Zeichnung - Zylinderhalterung}\stepcounter{page}
	\addcontentsline{toc}{chapter}{Zeichnung - Gestell}\stepcounter{page}
	\addcontentsline{toc}{chapter}{Zeichnung - Zylinder}\stepcounter{page}
	\addcontentsline{toc}{chapter}{Zeichnung - Ventilblöcke}\stepcounter{page}
	\addcontentsline{toc}{chapter}{Zeichnung - Podest}\stepcounter{page}
	\addcontentsline{toc}{chapter}{Zeichnung - Gesamtaufbau}\stepcounter{page}
}

\begin{document}

\tableofcontents
asdfwef
%\blinddocument
\chapter{Algorithmen und Datenstrukturen in ES6+}
\section{Warum in ES6+}
- ES is eating the world

- meaningful understanding

- I spent most of my professional life writing in JS and I think I know most about it

Und, um sicher zu sein, dass ich nicht versehentlich ein Beispiel für etwas
erzeugt, was gar nicht der Problemfall ist, wird der Problemfall jetzt
erzwungen:
\clearpage

% Num, um zu beweisen, dass wir beim Problemfall sind.
\addcontentsline{toc}{chapter}{Das kommt nie an}
asldf jlwefjlwkejf 
\addcontentsline{toc}{chapter}{Das kommt nie an}
\section{Nicht behandelte Themen}
- Promises
- async/await
- webAPI
- Browser spezifische Unterschiede

\chapter{Entwicklungsumgebung}
JS ist eine interpretierte Sprache. Sie läuft auf einer JS Engine. Die JS Engine läuft auf jeden Browser. Man kann direkt im Browser den Code ausführen.

Sobald man den Browser aber neu lädt ist unser Code weg. Besser ist es den Code entweder in nodejs auszuführen.

File speichern und mit node [filename] ausführen
\chapter{JavaScript Paradigmen}
JS ist eine sog. Multiparadigmen Programmiersprache. JS ist imperativ, objektorientiert und funktional. 
\section{Objekte und Object-Orientiertes Programmieren}
\section{Funktionales Programmieren}
\chapter{JavaScript Konstrukte}
\section{Entscheidungskonstrukte}
In JS gibt es if Statements, ternary und switch statement.
if
if else
if else if 
ternary operator

Return 

statement vs. expression
switch

\section{Wiederholungen}
for loop, while loop, symbol iterator; Generator; yields

\section{Funktionen}
\section{Scope}
\section{Closures}
\section{Call by Reference vs. Call by Value}

\chapter{Datenstrukturen}
\section{Array}
JS hat im Vergleich zu Java oder C/C++ nur sehr wenige Datenstrukturen. Eines ihrer wichtigsten Datenstrukturen ist der Array. Das Array werden wir später dazu benutzen, um alle anderen komplexeren Datenstrukturen zu implementieren. Der Unterschied zu JSs Arrays im Vergleich zu anderen Programmiersprachen ist, dass Arrays in JS keine fixe Länge haben. Durch das Hinzufügen und Entfernen von Elementen verändert sich die Array-Länge dynamisch mit. Bei der Initialisierung muss man dem Array dadurch auch keine bestimmte Länge mitgeben werden.

Arrays können in JS auf zwei Arten erstellt werden: Mit dem Array Konstruktor oder mit Array Literal:
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayConstructor = new Array();
var myArrayLiteral = [];
\end{lstlisting}

Der Array Konstruktur wird mit \lstinline|new| eingeleitet und darauf folgt \lstinline|Array()|. Beim Array Literal wird nur eine eckige Klammer \lstinline|[]| benötigt. Beide Möglichkeiten erstellen einen Array. Jedoch wird angeraten zur Erstellung eines Arrays das Array Literal zu nehmen. Nicht nur ist er kürzer und auch schneller, er ist auch syntaktisch eindeutiger. Denn mit dem Array Konstruktur kann man auch die Länge des Arrays definieren als auch initialisieren. Die Syntax von beiden Konstrukten sind sich ähnlich, sodass es zu Verwirrung kommen kann, wenn man den Array mit Zahlen initialisiert:

\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
var myArrayInit = new Array(3,2,1);
\end{lstlisting}

Die Länge eines Arrays wird als Zahl (hier: 3) in den Konstruktur reingeschrieben. Damit hat das Array in unserem Beispiel eine Länge von 3, die man mit \lstinline|length| überprüfen kann. Die (hier 3) Elemente sind noch \lstinline|undefined|, da sie noch nicht initialisiert sind. Bei der Initialisierung gibt man die Elemente ebenfalls in den Konstruktur mit ein, jeweils getrennt durch einen Komma. 
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
console.log(myArrayLength); 
// [undefined, undefined, undefined]
console.log(myArrayLenth.length); 
// 3

var myArrayInit = new Array(3,2,1);
console.log(myArrayInit); 
// [3, 2, 1]
console.log(myArrayInit.length); 
// 3
\end{lstlisting}

JS ist nicht static typed. D.h. ein Array kann Elemente nicht nur eines Typen gleichzeitig aufnehmen, sondern auch verschiedene. Ein Array in JS kann damit auch Zahlen, Strings, Bool und Objekte gleichzeitig aufnehmen:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
\end{lstlisting}

Intern werden die Elemente in einen String gecastet. Dadurch sind Arrays in JS langsamer als in anderen Sprachen. Um auf ein Array-Element zuzugreifen benutzen wir die eckige Klammer \lstinline|[]|. Ein Array ist Index basiert und fängt mit \lstinline|0| an. Um auf das zweite Element in einen Array zuzugreifen, schreiben wir also \lstinline|myArray[1]|:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
console.log(myArray[1]);
// "42"
\end{lstlisting}

JS bieten viele Funktionen zur Manipulationen von Arrays an.
Zum Hinzufügen am Ende wird \lstinline|push()| benutzt. Um ein Element am Anfang des Arrays hinzuzufügen, wird \lstinline|unshift()| verwendet:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
myArray.push(4);
console.log(myArray); 
// [1, 2, 3, 4]

myArray.unshift(0);
console.log(myArray); 
// [0, 1, 2, 3, 4]
\end{lstlisting}

Für das Entfernen am Ende des Arrays gibt es \lstinline|pop()|. Die Funktion \lstinline|pop()| entfernt das letzte Element und gibt das entfernte Element zurück. Für das Entfernen am Anfang des Arrays verwendet man \lstinline|shift()|. 

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [0, 1, 2, 3, 4];
console.log(myArray.pop());
// 4
console.log(myArray); 
// [0, 1, 2, 3]

console.log(myArray.shift());
// 0
console.log(myArray); 
// [1, 2, 3]
\end{lstlisting}

Um Elemente hinzuzufügen, zu ersetzen oder zu entfernen, die sich in der Mitte des Arrays befinden, verwendet man \lstinline|splice()|. \lstinline|splice()| nimmt als ersten Parameter den Index, an den das neue Element man hinzufügen will. Als zweiten Parameter wieviele Elemente danach ersetzt wird. Alle darauffolgenden Paramter die hinzuzufügenden Elemente.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 3, 4];
myArray.splice(1,0,2); 
// adds a new element, 2, at index 1

myArray.splice(3,0,5,6,7); 
// adds new elements, 5,6, and 7, at index 3

myArray.splice(5, 1); 
// removes one element at index 5

myArray.splice(2, 3); 
// removes 3 elements starting at index 2

myArray.splice(3, 1, 99); 
// replaces one element at index 3 with the new element 99

myArray.splice(3, 2, 42); 
// replaces 2 elements starting at index 3 with the new element 42

myArray.splice(999,0,2); 
// if the index (first parameter) is larger than the array length, then it will just adds a new element to the end
\end{lstlisting}

Die Elemente in einen Array kann man mit \lstinline|sort()| sortieren. \lstinline|sort()| nimmt eine Methode auf, die zwei Elemente miteinander vergleicht und entweder eine positive oder negative Zahl zurückgibt oder \lstinline|0|. Eine negative Zahl steht dafür, dass die Zahl kleiner ist. Eine positive Zahl steht dafür, dass die Zahl größer ist. Eine \lstinline|0| steht dafür, dass beide Zahlen gleich sind.

Beim Sortieren von Strings ist keine Funktion notwendig. Jedoch kann man eine mitgeben bei der überprüft wird, ob ein String größer ist als ein anderer String. Wenn man jedoch bei der Sortierung von Zahlen sich auf die Default \lstinline|sort()| Funktion verlässt, dann können die Zahlen falsch sortiert werden:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b);
console.log(myArray);
// [1, 4, 5, 8, 1001]

var myArray = [1, 5, 1001, 8, 4];
myArray.sort();
console.log(myArray);
// [1, 1001, 4, 5, 8]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort();
console.log(myArray);
// ["a", "bd", "c", "xxx"]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => a > b ? 1 : -1);
console.log(myArray);
// ["a", "bd", "c", "xxx"]
\end{lstlisting}

Man kann die \lstinline|sort()| Methode auch benutzen, um ein Array absteigend zu sortieren. Dazu kehrt man das Vorzeichen der mitzugebenden Funktion um:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => b - a);
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => (a > b ? -1 : 1));
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Alternativ kann man zur Umkehrung des Arrays auch die \lstinline|reverse()| Funktion benutzen. Diese ist sogar etwas schneller als nur die Sort Funktion mit der Methode und dem umgekehrten Vorzeichen von oben zu benutzen.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b).reverse();
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort().reverse();
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Die Funktionen \lstinline|push(), unshift(), pop(), shift(), splice()|, usw. verändern den originären Array. Es gibt auch Funktionen, die das Original nicht ändert, sondern stattdessen einen neuen Array zurückliefert.

Die \lstinline|map()| Methode geht durch die Elemente durch und wendet dabei eine ihr mitgegebene Methode \lstinline|(currentValue, index, array) => {}| auf jedes einzelne Element im Array an. Die ihr mitgegebene Methode nimmt als erstes Argument das aktuelle Element auf. Das zweite Element ist das momentane Index im Array. Das dritte Argument das ursprüngliche Array. Das Ergebnis ist wieder ein Array mit derselben Länge, wie das ursprüngliche Array:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4];
function multiplyBy2 = item => item * 2;
var doubleArray = myArray.map(multiplyBy2);
console.log(doubleArray);
// [2, 4, 6, 8]
\end{lstlisting}

Die \lstinline|filter()| Methode nimmt ebenfalls eine Funktion als Argument auf und wendet sie auf alle Elemente im Array an. Nur wenn die Auswertung dieser Funktion auf das aktuelle Element \lstinline|truthy| zurückgibt, wird dieses Element auch Teil des später zurückgegebenen Arrays. Die ihr übergebene Methode \lstinline|(currentValue, index, array) => {}| hat als erstes Argument das aktuelle Element. Das zweite Argument ist der aktuelle Index. Das dritte Argument das original Array auf das die \lstinline|filter()| Methode angewendet wird. Nur das erste Argument ist verpflichtend. Die restlichen sind optional. Beispielhaft ist unten die \lstinline|filter()| Methode zum Filtern von nur geraden Zahlen gezeigt:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4, 5, 6];
function isEven = item => item % 2 ;
var onlyEven = myArray.map(isEven);
console.log(onlyEven);
// [2, 4, 6]
\end{lstlisting}

Die \lstinline|reduce()| Methode unterscheidet sich von \lstinline|map()| und \lstinline|filter()| dadurch, dass nicht immer ein Array zurück gegeben werden muss. Stattdessen reduziert die Methode das Array auf einen einzigen Wert. Dieser Wert kann eine Zahl oder auch ein Array sein. Als erstes Argument kann sie eine Methode nehmen. Als zweites Argument nimmt sie einen initial Wert an. Das zweite Argument ist nur optional. Die Methode, die sie aufnimmt, \lstinline|(acc, item, index, array) => {}| hat als erstes Argument einen Akkumulator, der den kumulierten Wert enthält und der am Ende das Ergebnis darstellt. Das zweite Argument ist der aktuelle Wert. Das dritte Argument der Index und das vierte das original Array. Nur die ersten beiden Argumente sind verpflichtend.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var sum = (acc, item) => acc + item;
var sumOfArray = myArray.reduce(sum, 0);
// 6
\end{lstlisting}

Die Methode \lstinline|flat()|\footnote{noch im Experiment Status, d.h. es wurde noch nicht von allen JS Engines implementiert} wird auf Arrays angewendet, die selbst wiederum Arrays enthalten. Sie erstellt ein neues Arrays mit allen Unterarrays. Dabei kann optional bestimmt werden bis zu welcher Ebene die Unterarrays aufgelöst werden. Die \lstinline|flat()| Methode nimmt optional nur einen numerischen Wert an. Dieser legt fest bis zu welcher Ebene die Unterarrays aufgelöst werden.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, [4, 5, 6]];
console.log(myArray.flat());
// [1, 2, 3, 4, 5, 6]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat());
// [1, 2, 3, 4, [5, 6]]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat(2));
// [1, 2, 3, 4, 5, 6]

\end{lstlisting}

Die \lstinline|flat()| Methode wird auch genutzt, um leere Elemente in Arrays zu entfernen
\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, , ,6];
console.log(myArray.flat());
// [1, 2, 3, 6]
\end{lstlisting}

Die Methode \lstinline|flatMap()| \footnote{noch im Experimentier Status, d.h. nicht alle Browser haben es implementiert} ist identisch zum Aufruf einer \lstinline|map()| Methode gefolgt vom Aufruf einer \lstinline|flat()| Methode. Die Methode wendet eine ihr mitgegebene Funktion auf alle Elemente an und flacht sie anschießend ab. Die ihr mitgegebene Funktion \lstinline|(item, index, array) => {}| nimmt als erstes Argument das aktuelle Element. Das zweite Argument der Index und das dritte Argument das Original Array.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var duplicate = item => [item, item];
console.log(myArray.flatMap(duplicate));
// [1, 1, 2, 2, 3, 3]
\end{lstlisting}


\lstinline|every()|
\lstinline|some()|
Die \lstinline|slice()| Methode 
\lstinline|concat()|

Array kopieren. 

Element im Array finden

Strings in einen Array umwandeln

Array manipulieren: Hinzufügen (push, unshift), entfernen (des letzten pop, des ersten shift), Zugriff die Elemente. Subarray erstellen: splice (mit mutation), slice (ohne). Kopieren von Arrays (slice(0)), usw..... dieser Abschnitt eng in Abstimmmung mit der Implementierung der komplexen Datenstrukturen machen.

- arrays are only objects- values are converted to Strings- is slower than in other JS- creating an Array with Array literal or constructor - go with the array literal because it's faster and is more clear. Array constructor can be weird....e.g.: new Array(10); // creates new array of size 10 new Array(10, 9,8,7,6); // creates new array with the elements 10, 9, 8, etc.- different objects, e.g. strings, int, bool can be in one array- accessing array elements- writing into array- can grow dynamicallly beyond the specified size- creating arrays from strings with split()- Assign array to another, shallow copy- How to copy array- searching for an value, indexOf(), return the first element, lastIndexOf(), returns the last element- exists value, includes()- return string from an array: toString(), join()- creating new arrays from existing ones: concat(), splice()- mutator functions: shift(), push(), pop(), - reordering reverse(), sort(); (sort doesn't work well with numbers!)- adding and removeing elements from the middle of an array: splice()- iterator functions: forEach, every(), some(), map(), filter(), reduce(), reduceRight(), flat(), flatMap()- multidimensional Array

\section{Liste}
asldfjlkewjf
Lists are convenient if the order doesn't matter or if you don't have to search for a certain item
implement a listlistSize (property) Number of elements in list
pos (property) Current position in list
length (property) Returns the number of elements in list
clear (function) Clears all elements from list
toString (function) Returns string representation of list
getElement (function) Returns element at current position
insert (function) Inserts new element after existing element
append (function) Adds new element to end of list
remove (function) Removes element from list
front (function) Sets current position to first element of list
end (function) Sets current position to last element of list
prev (function) Moves current position back one element
next (function) Moves current position forward one element
currPos (function) Returns the current position in list
moveTo (function) Moves the current position to specified position

While writing also test your impelmentation with console.assert()
\section{Stack}
\section{Queue}
\section{Dequeue}
\section{Priority Queue}
\section{LinkedList}
\section{Zirkulare LinkedList}
\section{Zweifach verknüpfte LinkedList}
\section{Dictionary}
\section{Hashing}
\section{HashMap}
\section{MapTree}
\section{LinkedMap}
\section{Sets}
\section{Binäre Bäume}
\section{Graphen}
\section{AVL Tree}

\chapter{Algorithmen}
Sortier Algorithmen und Such Algorithmen
\section{Breitensuche}
\section{Tiefensuche}
\section{Bubble Sort}
\section{Selection Sort}
\section{Shellsort}
\section{Mergesort}
\section{Quicksort}
\section{Sequential Suche}
\section{Binäres Suchen}
\section{Suchen nach Minimum und Maximum}
\section{Rucksackproblem}
\section{Greedy Algorithm}

\medskip
\begin{lstlisting}[caption=My Javascript Example]
Name.prototype = {
  methodName: function(params){
    var doubleQuoteString = "some text";
    var singleQuoteString = 'some more text';
    // this is a comment
    if(this.confirmed != null && typeof(this.confirmed) == Boolean && this.confirmed == true){
      document.createElement('h3');
      $('#system').append("This looks great");
      return false;
    } else {
      throw new Error;
    }
  }
}
\end{lstlisting}
laskd flwkejf wlekjf ew
\end{document}
\documentclass{book}

\usepackage[table]{xcolor}% http://ctan.org/pkg/xcolor; % table cell color

\usepackage{blindtext}
\usepackage{scrlfile}
% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, undefined, catch, switch, var, let, const, if, in, while, do, else, case, break, push, pop, shift, unshift},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
}

\usepackage{amsthm}
\usepackage[framemethod=tikz]{mdframed}
\usepackage[most]{tcolorbox}
\usepackage{lipsum}% just to generate text for the example
\usepackage{hyperref}

\newmdtheoremenv[
hidealllines=true,
leftline=true,
innertopmargin=0pt,
innerbottommargin=0pt,
linewidth=4pt,
linecolor=gray!40,
innerrightmargin=0pt,
innertopmargin=-6pt,
]{examplei}{Aufgabe}

\newtcolorbox{exampleii}{
	freelance,
	breakable,
	width=\dimexpr\textwidth+28pt\relax,
	before=\par\vspace{\bigskipamount}\noindent,
	enlarge left by=-14pt,
	overlay unbroken and first={
		\node[
		anchor=north east,
		inner xsep=8pt,
		xshift=8pt,
		rounded corners=5pt,
		font=\bfseries,
		fill=white] at ([xshift=-0.2cm]frame.north west) (tit) {\strut Example:};
		\draw[
		line width=3pt,
		rounded corners=5pt,gray
		] ([xshift=4pt]frame.north west) -- ([xshift=4pt]frame.south west);
	},
	overlay middle and last={
		\draw[
		line width=3pt,
		rounded corners=5pt,gray
		] ([xshift=4pt]frame.north west) -- ([xshift=4pt]frame.south west);
	},
	frame code={},
	interior code={},
	top=0pt,
	bottom=0pt
}

\renewcommand{\contentsname}{Inhalt}
\renewcommand{\chaptername}{Kapitel}

\begin{document}
\tableofcontents
%\blinddocument
\chapter{Algorithmen und Datenstrukturen in ES6+}

Dieses Buch ist noch in Bearbeitung....
\section{Warum in ES6+}
- ES is eating the world

- meaningful understanding

- I spent most of my professional life writing in JS and I think I know most about it

\section{Behandelte Themen}
- Algos und DS
- Übungen am Ende. Versuche die Aufgaben zu machen ohne auf die Lösung zu schauen. Da ich finde, dass man von Fehlern oft viel mehr lernen kann als von richtigen Lösungen, habe ich vor der eigentlichen Lösung noch typische Fehler aufgelistet.

\section{Nicht behandelte Themen}
- Promises
- async/await
- webAPI
- Browser spezifische Unterschiede

\chapter{Entwicklungsumgebung}
JS ist eine interpretierte Sprache. Sie läuft auf einer JS Engine. Die JS Engine läuft auf jeden Browser. Man kann direkt im Browser den Code ausführen.

Sobald man den Browser aber neu lädt ist unser Code weg. Besser ist es den Code entweder in nodejs auszuführen.

File speichern und mit node [filename] ausführen
\chapter{JavaScript Paradigmen}
JS ist eine sog. Multiparadigmen Programmiersprache. JS ist imperativ, objektorientiert und funktional. 
\section{Object-Orientiertes Programmieren}
\section{Funktionales Programmieren}
\chapter{JavaScript Konstrukte}
\section{Entscheidungskonstrukte}
In JS gibt es if Statements, ternary und switch statement.
if
if else
if else if 
ternary operator

Return 

statement vs. expression
switch

\section{Wiederholungen}
for loop, while loop, do while loop, symbol iterator; Generator; yields, for...of, for ...in

\section{Funktionen}
Es gibt verschiedene Arten Funktionen in JS zu definieren. 

\begin{lstlisting}[caption=Array Konstruktor]
function functionDeclaration() {
	//...
}
\end{lstlisting}

\begin{lstlisting}[caption=Array Konstruktor]
var functionExpression = function() {
	//...
}
\end{lstlisting}

\begin{lstlisting}[caption=Anonymous function]
function() {
	//...
}
\end{lstlisting}

\begin{lstlisting}[caption=Arrow function]
() => {
	//...
}
\end{lstlisting}


\begin{lstlisting}[caption=IIFE]
(function() {
	//..
})();
\end{lstlisting}


\begin{lstlisting}[caption=IIFE]
var functionConstructor = new Function('a','b','return a + b');
\end{lstlisting}

\section{Scope}
\section{Closures}
\section{Hoisting}
\section{Call by Reference vs. Call by Value}
\section{Truthy und falsy}
\section{this}
\section{strict/sloppy mode}
\section{Number.EPSILON}
Vergleich, ob Addition funktioniert

\chapter{Datenstrukturen}
Datenstrukturen lassen sich grob in drei Kategorien einteilen:
\begin{enumerate} 
	\item Array ähnliche Strukturen
	
	Dazu gehören Stacks und Queues. Diese Strukturen unterscheiden sich nur darin wie die Elemente eingefügt und entfernt werden.
	\item Strukturen mit Knoten-Referenzen
	
	Strukturen, die eine Referenz zu einen Knoten haben sind LinkedList, Bäume und Graphen
	
	\item Hash Tabellen
	Hash Tabellen sind von Hash Funktionen abhängig, um Daten zu speichern und zu finden.
	
\end{enumerate}

\section{Array}
JS hat im Vergleich zu Java oder C/C++ nur sehr wenige Datenstrukturen. Eines ihrer wichtigsten Datenstrukturen ist der Array. Das Array werden wir später dazu benutzen, um alle anderen komplexeren Datenstrukturen zu implementieren. Der Unterschied zu JSs Arrays im Vergleich zu anderen Programmiersprachen ist, dass Arrays in JS keine fixe Länge haben. Durch das Hinzufügen und Entfernen von Elementen verändert sich die Array-Länge dynamisch mit. Bei der Initialisierung muss man dem Array dadurch auch keine bestimmte Länge mitgeben werden.

Arrays können in JS auf zwei Arten erstellt werden: Mit dem Array Konstruktor oder mit Array Literal:
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayConstructor = new Array();
var myArrayLiteral = [];
\end{lstlisting}

Der Array Konstruktur wird mit \lstinline|new| eingeleitet und darauf folgt \lstinline|Array()|. Beim Array Literal wird nur eine eckige Klammer \lstinline|[]| benötigt. Beide Möglichkeiten erstellen einen Array. Jedoch wird angeraten zur Erstellung eines Arrays das Array Literal zu nehmen. Nicht nur ist er kürzer und auch schneller, er ist auch syntaktisch eindeutiger. Denn mit dem Array Konstruktur kann man auch die Länge des Arrays definieren als auch initialisieren. Die Syntax von beiden Konstrukten sind sich ähnlich, sodass es zu Verwirrung kommen kann, wenn man den Array mit Zahlen initialisiert:

\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
var myArrayInit = new Array(3,2,1);
\end{lstlisting}

Die Länge eines Arrays wird als Zahl (hier: 3) in den Konstruktur reingeschrieben. Damit hat das Array in unserem Beispiel eine Länge von 3, die man mit \lstinline|length| überprüfen kann. Die (hier 3) Elemente sind noch \lstinline|undefined|, da sie noch nicht initialisiert sind. Bei der Initialisierung gibt man die Elemente ebenfalls in den Konstruktur mit ein, jeweils getrennt durch einen Komma. 
\begin{lstlisting}[caption=Array Konstruktor]
var myArrayLength = new Array(3);
console.log(myArrayLength); 
// [undefined, undefined, undefined]
console.log(myArrayLenth.length); 
// 3

var myArrayInit = new Array(3,2,1);
console.log(myArrayInit); 
// [3, 2, 1]
console.log(myArrayInit.length); 
// 3
\end{lstlisting}

JS ist nicht static typed. D.h. ein Array kann Elemente nicht nur eines Typen gleichzeitig aufnehmen, sondern auch verschiedene. Ein Array in JS kann damit auch Zahlen, Strings, Bool und Objekte gleichzeitig aufnehmen:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
\end{lstlisting}

Intern werden die Elemente in einen String gecastet. Dadurch sind Arrays in JS langsamer als in anderen Sprachen. Um auf ein Array-Element zuzugreifen benutzen wir die eckige Klammer \lstinline|[]|. Ein Array ist Index basiert und fängt mit \lstinline|0| an. Um auf das zweite Element in einen Array zuzugreifen, schreiben wir also \lstinline|myArray[1]|:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, "42", true, "hi", {"hello": "world"}];
console.log(myArray[1]);
// "42"
\end{lstlisting}

JS bieten viele Funktionen zur Manipulationen von Arrays an.
Zum Hinzufügen am Ende wird \lstinline|push()| benutzt. Um ein Element am Anfang des Arrays hinzuzufügen, wird \lstinline|unshift()| verwendet:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
myArray.push(4);
console.log(myArray); 
// [1, 2, 3, 4]

myArray.unshift(0);
console.log(myArray); 
// [0, 1, 2, 3, 4]
\end{lstlisting}

Für das Entfernen am Ende des Arrays gibt es \lstinline|pop()|. Die Funktion \lstinline|pop()| entfernt das letzte Element und gibt das entfernte Element zurück. Für das Entfernen am Anfang des Arrays verwendet man \lstinline|shift()|. 

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [0, 1, 2, 3, 4];
console.log(myArray.pop());
// 4
console.log(myArray); 
// [0, 1, 2, 3]

console.log(myArray.shift());
// 0
console.log(myArray); 
// [1, 2, 3]
\end{lstlisting}

Um Elemente hinzuzufügen, zu ersetzen oder zu entfernen, die sich in der Mitte des Arrays befinden, verwendet man \lstinline|splice()|. \lstinline|splice()| nimmt als ersten Parameter den Index, an den das neue Element man hinzufügen will. Als zweiten Parameter wieviele Elemente danach ersetzt wird. Alle darauffolgenden Paramter die hinzuzufügenden Elemente. 

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 3, 4];
myArray.splice(1,0,2); 
// adds a new element, 2, at index 1

myArray.splice(3,0,5,6,7); 
// adds new elements, 5,6, and 7, at index 3

myArray.splice(5, 1); 
// removes one element at index 5

myArray.splice(2, 3); 
// removes 3 elements starting at index 2

myArray.splice(3, 1, 99); 
// replaces one element at index 3 with the new element 99

myArray.splice(3, 2, 42); 
// replaces 2 elements starting at index 3 with the new element 42

myArray.splice(999,0,2); 
// if the index (first parameter) is larger than the array length, then it will just adds a new element to the end

\end{lstlisting}

Gibt man nur eine Zahl als Argument mit, dann entfernt \lstinline|splice()| die Elemente ab dem Index an der angegebenen Zahl bis zum Arrayende. Übergibt man eine Zahl, die gleich 0 ist oder größer oder gleich als die Länge des Arrays, dann wird das Ursprungsarray nicht verändert. Übergibt man eine negative Zahl, wird nicht von links, sondern von rechts gezählt und nach dem \lstinline|n|-ten (von rechts) Element die Elemente entfernt.

Wenn nur ein Argument übergeben wird, dann gibt die \lstinline|splice()| Funktion als Ergebnis die entfernten Elemente als Array zurück. Bei allen anderen Parameterübergaben, gibt sie nur einen leeren Array zurück.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1,2,3,4,5,6,7,8,9,10];
var removedElements = myArray.splice(4);
console.log(removedElements);
// [5,6,7,8,9,10]
console.log(myArray);
// [1,2,3,4]

var myArray = [1,2,3,4,5,6,7,8,9,10];
var removedElements = myArray.splice(99);
console.log(removedElements);
// []
console.log(myArray);
// array remains unchanged

var myArray = [1,2,3,4,5,6,7,8,9,10];
var removedElements = myArray.splice(-3);
console.log(removedElements);
// [8,9,10]
console.log(myArray);
// [1,2,3,4,5,6,7]
\end{lstlisting}

Die Elemente in einen Array kann man mit \lstinline|sort()| sortieren. \lstinline|sort()| nimmt eine Methode auf, die zwei Elemente miteinander vergleicht und entweder eine positive oder negative Zahl zurückgibt oder \lstinline|0|. Eine negative Zahl steht dafür, dass die Zahl kleiner ist. Eine positive Zahl steht dafür, dass die Zahl größer ist. Eine \lstinline|0| steht dafür, dass beide Zahlen gleich sind.

Beim Sortieren von Strings ist keine Funktion notwendig. Jedoch kann man eine mitgeben bei der überprüft wird, ob ein String größer ist als ein anderer String. Wenn man jedoch bei der Sortierung von Zahlen sich auf die Default \lstinline|sort()| Funktion verlässt, dann können die Zahlen falsch sortiert werden:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b);
console.log(myArray);
// [1, 4, 5, 8, 1001]

var myArray = [1, 5, 1001, 8, 4];
myArray.sort();
console.log(myArray);
// [1, 1001, 4, 5, 8]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort();
console.log(myArray);
// ["a", "bd", "c", "xxx"]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => a > b ? 1 : -1);
console.log(myArray);
// ["a", "bd", "c", "xxx"]
\end{lstlisting}

Man kann die \lstinline|sort()| Methode auch benutzen, um ein Array absteigend zu sortieren. Dazu kehrt man das Vorzeichen der mitzugebenden Funktion um:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => b - a);
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort((a, b) => (a > b ? -1 : 1));
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Alternativ kann man zur Umkehrung des Arrays auch die \lstinline|reverse()| Funktion benutzen. Diese ist sogar etwas schneller als nur die Sort Funktion mit der Methode und dem umgekehrten Vorzeichen von oben zu benutzen.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 5, 1001, 8, 4];
myArray.sort((a,b) => a - b).reverse();
console.log(myArray);
// [1001, 8, 5, 4, 1]

var myArray = ["a", "c", "xxx", "bd"];
myArray.sort().reverse();
console.log(myArray);
// ["xxx", "c", "bd", "a"]
\end{lstlisting}

Die Funktionen \lstinline|push(), unshift(), pop(), shift(), splice()|, usw. verändern den originären Array. Es gibt auch Funktionen, die das Original nicht ändert, sondern stattdessen einen neuen Array zurückliefert.

Die \lstinline|map()| Methode geht durch die Elemente durch und wendet dabei eine ihr mitgegebene Methode \lstinline|(currentValue, index, array) => {}| auf jedes einzelne Element im Array an. Die ihr mitgegebene Methode nimmt als erstes Argument das aktuelle Element auf. Das zweite Element ist das momentane Index im Array. Das dritte Argument das ursprüngliche Array. Das Ergebnis ist wieder ein Array mit derselben Länge, wie das ursprüngliche Array:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4];
function multiplyBy2 = item => item * 2;
var doubleArray = myArray.map(multiplyBy2);
console.log(doubleArray);
// [2, 4, 6, 8]
\end{lstlisting}

Die \lstinline|filter()| Methode nimmt ebenfalls eine Funktion als Argument auf und wendet sie auf alle Elemente im Array an. Nur wenn die Auswertung dieser Funktion auf das aktuelle Element \lstinline|truthy| zurückgibt, wird dieses Element auch Teil des später zurückgegebenen Arrays. Die ihr übergebene Methode \lstinline|(currentValue, index, array) => {}| hat als erstes Argument das aktuelle Element. Das zweite Argument ist der aktuelle Index. Das dritte Argument das original Array auf das die \lstinline|filter()| Methode angewendet wird. Nur das erste Argument ist verpflichtend. Die restlichen sind optional. Beispielhaft ist unten die \lstinline|filter()| Methode zum Filtern von nur geraden Zahlen gezeigt:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, 4, 5, 6];
function isEven = item => item % 2 ;
var onlyEven = myArray.map(isEven);
console.log(onlyEven);
// [2, 4, 6]
\end{lstlisting}

Die \lstinline|reduce()| Methode unterscheidet sich von \lstinline|map()| und \lstinline|filter()| dadurch, dass nicht immer ein Array zurück gegeben werden muss. Stattdessen reduziert die Methode das Array auf einen einzigen Wert. Dieser Wert kann eine Zahl oder auch ein Array sein. Als erstes Argument kann sie eine Methode nehmen. Als zweites Argument nimmt sie einen initial Wert an. Das zweite Argument ist nur optional. Die Methode, die sie aufnimmt, \lstinline|(acc, item, index, array) => {}| hat als erstes Argument einen Akkumulator, der den kumulierten Wert enthält und der am Ende das Ergebnis darstellt. Das zweite Argument ist der aktuelle Wert. Das dritte Argument der Index und das vierte das original Array. Nur die ersten beiden Argumente sind verpflichtend.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var sum = (acc, item) => acc + item;
var sumOfArray = myArray.reduce(sum, 0);
// 6
\end{lstlisting}

Die \lstinline|reduce()| Funktion geht im Array von links nach rechts. Mit der \lstinline|reduceRight()| geht die Funktion von rechts nach links.

Die Methode \lstinline|flat()|\footnote{noch im Experiment Status, d.h. es wurde noch nicht von allen JS Engines implementiert} wird auf Arrays angewendet, die selbst wiederum Arrays enthalten. Sie erstellt ein neues Arrays mit allen Unterarrays. Dabei kann optional bestimmt werden bis zu welcher Ebene die Unterarrays aufgelöst werden. Die \lstinline|flat()| Methode nimmt optional nur einen numerischen Wert an. Dieser legt fest bis zu welcher Ebene die Unterarrays aufgelöst werden.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, [4, 5, 6]];
console.log(myArray.flat());
// [1, 2, 3, 4, 5, 6]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat());
// [1, 2, 3, 4, [5, 6]]

var myArray = [1, 2, 3, [4, [5, 6]]];
console.log(myArray.flat(2));
// [1, 2, 3, 4, 5, 6]

\end{lstlisting}

Die \lstinline|flat()| Methode wird auch genutzt, um leere Elemente in Arrays zu entfernen
\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3, , ,6];
console.log(myArray.flat());
// [1, 2, 3, 6]
\end{lstlisting}

Die Methode \lstinline|flatMap()| \footnote{noch im Experimentier Status, d.h. nicht alle Browser haben es implementiert} ist identisch zum Aufruf einer \lstinline|map()| Methode gefolgt vom Aufruf einer \lstinline|flat()| Methode. Die Methode wendet eine ihr mitgegebene Funktion auf alle Elemente an und flacht sie anschießend ab. Die ihr mitgegebene Funktion \lstinline|(item, index, array) => {}| nimmt als erstes Argument das aktuelle Element. Das zweite Argument der Index und das dritte Argument das Original Array.

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = [1, 2, 3];
var duplicate = item => [item, item];
console.log(myArray.flatMap(duplicate));
// [1, 1, 2, 2, 3, 3]
\end{lstlisting}

Die Funktion \lstinline|concat()| vereint zwei Arrays und liefert das vereinigte Array als neues Array wieder zurück:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray1 = ["a", "b", "c", "x"];
var myArray2 = ["d", "e", "f"];
var newArray = myArray1.concat(myArray2);
console.log(newArray);
// ["a", "b", "c", "x", "d", "e", "f"]
\end{lstlisting}

Eine andere Möglichkeit ist es den Rest/Spread Operator zu verwenden:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray1 = ["a", "b", "c", "x"];
var myArray2 = ["d", "e", "f"];
var newArray = [...myArray1, ...myArray2];
console.log(newArray);
// ["a", "b", "c", "x", "d", "e", "f"]
\end{lstlisting}

Die \lstinline|copyWithin()| Funktion kopiert einen Teil des Arrays in einer anderen Stelle desselben Arrays. Dabei wird die Länge des Arrays beibehalten. 

\begin{lstlisting}[caption=Array Konstruktor]
var myArray1 = [1,2,3,4,5,6,7,8,9];
console.log(myArray1.copyWithin(1,3,6));
// Copies the numbers starting at index 3 to (exclusive) 6, i.e. [4,5,6] to the index 1
// [1,4,5,6,5,6,7,8,9]

console.log(myArray1.copyWithin(1,3));
// Copies the numbers starting at index 3 to the end, i.e. [4,5,6,7,8,9] to the index 1
// [1,4,5,6,7,8,9,8,9]
\end{lstlisting}

Die \lstinline|slice()| Methode erstellt eine (flache) Kopie des Arrays und gibt diese Kopie als neues Array zurück. Die Methode nimmt zwei Argumente auf. Das erste Argument beschreibt ab welchem Index die Kopie erstellt wird. Das zweite optionale Argument beschreibt bis zu welchem (exklusve) Index das Array kopiert wird. Wird für das zweite Argument kein Wert gegeben, dann kopiert er bis zum Arrayende:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArray = myArray.slice(0);
console.log(newArray);
// ["a", "b", "c", "x"]
\end{lstlisting}

Eine flache Kopie deshalb, weil die Funktion die Elemente als Referenz in das neue Array schreibt. D.h. jede Änderung im original Array hat Auswirkung auf das neue Array. Dies gilt jedoch nicht für \lstinline|Number|, \lstinline|String|, \lstinline|boolean|, \lstinline|null|, \lstinline|undefined|, \lstinline|symbol|, sondern für \lstinline|object|, \lstinline|Array|, \lstinline|function|:

\begin{lstlisting}[caption=Array Konstruktor]
// Using slice, create newCar from myCar.
var myHonda = { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } };
var myCar = [myHonda, 2, 'cherry condition', 'purchased 1997'];
var newCar = myCar.slice(0, 2);
console.log(newCar);
// Display the values of myCar, newCar, and the color of myHonda
//  referenced from both arrays.
console.log('myCar[0].color = ' + myCar[0].color);
console.log('newCar[0].color = ' + newCar[0].color);

// Change the color of myHonda.
myHonda.color = 'purple';
console.log('The new color of my Honda is ' + myHonda.color);

// Display the color of myHonda referenced from both arrays.
console.log('myCar[0].color = ' + myCar[0].color);
console.log('newCar[0].color = ' + newCar[0].color);
\end{lstlisting}

Eine weitere Möglichkeit den Array zu kopieren ist mit Hilfe des Rest/Spread-Operators:
\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArray = [...myArray];
console.log(newArray);
// ["a", "b", "c", "x"]
\end{lstlisting}

Der Unterschied zwischen beiden Möglichkeiten ist, dass \lstinline|slice()| eine flache Kopie und der Rest/Spread Operator eine tiefen Kopie erstellt:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];
var newArrayShallow = myArray.slice(0);
var newArrayDeep = [...myArray];
console.log(myArray === newArrayShallow);
// true --> it's pointing to the same memory space

console.log(myArray === newArrayDeep);
// false --> it's pointing to a new memory space
\end{lstlisting}

Es sei hier erwähnt, dass der Rest/Spread Operator nur eine Ebene tief kopiert. Bei mehrdimensionalen Arrays muss man andere Methoden wählen. Unten sind Methoden aufgelistet mit der man eine tiefen Kopie, also einen Klon, erstellen kann:

\begin{lstlisting}[caption=Array Konstruktor]
var myArray = ["a", "b", "c", "x"];

var clonedArray1 = JSON.parse(JSON.stringify(myArray))
var clonedArray2 = [].concat(myArray);
var clonedArray2 = Array.from(myArray);
\end{lstlisting}

Wie im vorherigen Kapitel angesprochen gibt es die Möglichkeit durch ein Array mit einer Schleife zu iterieren. Die Arrays in JS bieten eigene Funktionen zum Iterieren an. Die \lstinline|forEach()| Funktion nimmt eine Methode und geht durch alle Elemente durch und wendet auf jedes einzelene ELement die Methode an. Die Funktion kann, im Gegensatz zu Schleifen wie \lstinline|for|, \lstinline|while|, \lstinline|do while|, usw. nicht unterbrochen werden \footnote{außer durch das Werfen einer Ausnahme (was aber nicht empfohlen wird).}.Die \lstinline|forEach()| Funktion liefert kein Ergebnis zurück.

\begin{lstlisting}[caption=Array Konstruktor]
[1,2,3,4,5].forEach((currentValue, index) => {
	console.log(`Value ${currentValue} at index ${index}`);
});
\end{lstlisting}

Will man vorher abbrechen so kann man entweder die \lstinline|every()| oder \lstinline|some()| verwenden. Die \lstinline|every()| nimmt eine Funktion auf und überprüft sie für alle Elemente. Sobald bei der Überprüfung bei eines der Elemente \lstinline|falsy| zurück gegeben wird, bricht sie ab. Bei der \lstinline|some()| wird die Iteration abgebrochen sobald bei der Auswertung \lstinline|truthy| zurückgegeben wird. Beide Funktionen geben \lstinline|true| bzw. \lstinline|false| zurück, wenn die Bedingung eingetroffen ist.

\begin{lstlisting}[caption=Array Konstruktor]
var hasLargerThanTen = [10,20,30].some(item => item > 10);
console.log(hasLargerThanTen);
// true

var hasSmallerThanTen = [10,20,30].some(item => item < 10);
console.log(hasSmallerThanTen);
// false

var allAreLargerThanTen = [10,20,30].every(item => item > 10);
console.log(allAreLargerThanTen);
// false

var allAreLargerThanTen = [100,20,30].every(item => item > 10);
console.log(allAreLargerThanTen);
// true
\end{lstlisting}

Oft will man ein Element im Array finden. Dazu kann man wieder Schleifen benutzen oder die Built-in Funktionen verwenden. 

Will man nur feststellen, ob ein Element auch im Array vorhanden ist, so kann man \lstinline|includes()| verwenden. Dieses gibt entweder \lstinline|true| oder \lstinline|false| zurück, wenn das Element im Array gefunden bzw. nicht gefunden wurde.

\begin{lstlisting}[caption=Array Konstruktor]
var hasNumberTwo = [1,2,3,4,5].includes(2);
console.log(hasNumberTwo);
// true

var hasNumberTen = [1,2,3,4,5].includes(10);
console.log(hasNumberTen);
// false
\end{lstlisting}

Will man noch dazu herauszufinden, an welcher Position das gesuchte Element sich befindet, gibt es \lstinline|indexOf()|. Diese nimmmt eine Funktion auf und liefert den ersten Index des Elements, bei der die mitgegebene Funktion \lstinline|truthy| zurückliefert. \lstinline|lastIndexOf()| macht genau das Gegenteil: sie gibt den Index des zu letzt gefundenen Elements zurück. Falls keines der Elemente den Bedingungen entspricht, liefert \lstinline|indexOf()| und \lstinline|lastIndexOf()| \lstinline|-1| zurück.

\begin{lstlisting}[caption=Array Konstruktor]
var position = ["a", "b", "c"]
\end{lstlisting}

Will man einen \lstinline|String|in einen Array umwandeln, so kann man wieder den Rest/Spread-Operator verwenden. Dabei wird jedes einzelne Zeichen, inklusive Leerzeichen, Komma, Sonderzeichen usw., als eigenes Element in ein neues Array gepackt und zurückgegeben.

\begin{lstlisting}[caption=Array Konstruktor]
var myString = "hello, world";
var myArray = [...myString];
console.log(myArray);
// ["h", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d"]
\end{lstlisting}

Mit \lstinline|split()| kann man festlegen ab wann man die Elemente in einen Array übergeben will. Die Funktion nimmt einen \lstinline|String| als Prädikat auf. Will man z.B. beim obigen Beispiel nur die Wörter in den Array geben, die durch einen Komma getrennt sind, so gibt man das als String in die Funktion ein:
\begin{lstlisting}[caption=Array Konstruktor]
var myString = "hello, world";
var myArray = myString.split(",")
console.log(myArray);
// ["hello", " world"]
\end{lstlisting}

\section{Liste}
Listen sind gut geeignet, wenn es nicht auf die Reihenfolge der Elemente ankommt und wenn man nicht nach einen bestimmten Element suchen muss. Nachfolgend wollen wir eine \lstinline|List|-Klasse implementieren, die folgende Eigenschaften und Funktionen hat:

\begin{itemize} 
	\item pos (property): Current position in list
	\item size (property): Returns the number of elements in list	
	\item clear (function): Clears all elements from list
	\item toString (function): Returns string representation of list
	\item get(function): Returns element at specified index. If nothing is specified then return element at current position
	\item indexOf (function): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element
	\item lastIndexOf (function): Returns the index of the last occurrence of the specified element in this list, or -1 if the list doesn't contain the specified element 
	\item isEmpty (function): Returns true if the list contains no element
	\item insert (function): Inserts new element after existing element
	\item add (function): Appends new element to end of list
	\item remove (function): Removes element at a specific position from list
	\item front (function): Sets current position to first element of list
	\item end (function): Sets current position to last element of list
	\item prev (function): Moves current position back one element
	\item next (function): Moves current position forward one element
	\item moveTo (function): Moves the current position to specified position	
	\item sublist(function): Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. 
\end{itemize}

\paragraph{List Klasse}
Nachfolgend werden wir die \lstinline|List| Klasse erstellen. Die gesamte Klasse inklusive den Tests zu dieser Klasse kann unter meinem GitHub Repo angeschaut werden. Die ganze Klasse findet ihr hier: \url{https://github.com/pandaquests/Datastructure_Algorithm_ES6/blob/master/code/datastructures/List.js}

Der Test zu der Klasse ist hier: \url{https://github.com/pandaquests/Datastructure_Algorithm_ES6/blob/master/code/test/datastructures/List.test.js}

Der Konstruktor kann einen Array aufnehmen oder leer bleiben. Wenn er leer bleibt, dann wird eine leere Liste erstellt.

\begin{lstlisting}[caption=Array Konstruktor]
class List {
	constructor(items = []) {
		this.store = items;
		this.pos = 0;
		this.size = items.length;
	}
	clear() { /*...*/ }
	toString() {/*...*/ }
	get(index) {/*...*/ }
	indexOf (item) {/*...*/}
	lastIndexOf () {/*...*/}
	isEmpty () {/*...*/}
	insert(index) {/*...*/ }
	add() {/*...*/ }
	remove() {/*...*/ }
	front() {/*...*/ }
	end() {/*...*/ }
	prev() {/*...*/ }
	next() {/*...*/ }
	moveTo(index) {/*...*/ }
	sublist(from, to) {/*...*/}
}
\end{lstlisting}

Die einzelenen noch leeren Funktionen werden wir nachfolgend mit Leben füllen. Die Eigenschaften können wir aber schon setzen. Bei einer Liste sind \lstinline|listSize|, \lstinline|pos|, \lstinline|size| zu Anfang selbstverständlich alle \lstinline|0|.

Erklären, was man mit der Position macht..... als Iterable..

\paragraph{clear() - Löschen aller Elemente einer Liste}
Beim Löschen muss der \lstinline|dataStore| sowie die Eigenschaft Länge und Position wieder auf den Initialzustand zurück versetzt werden.

\begin{lstlisting}[caption=Array Konstruktor]
clear() {
	this.store = [];
	this.size = this.pos = 0;	
}
\end{lstlisting}

\paragraph{toString() - Gibt die Repräsentation der Liste als String zurück} Bei der toString Funktion reicht es aus, wenn wir die \lstinline|dataStore| zurückgeben.

\begin{lstlisting}[caption=Array Konstruktor]
toString() {
	return this.store;
}
\end{lstlisting}

\paragraph{get(index) - Ein Element an einem bestimmten Index bekommen}
Diese Funktion bekommt einen Defaultwert. Falls der User nur \lstinline|get()| aufruft, bekommt er das Element bei der \lstinline|index = pos| ist. Gibt er eine Zahl ein, z.B. \lstinline|get(2)| bekommt er das Element ber der Index dieser Zahl entspricht.
\begin{lstlisting}[caption=Array Konstruktor]
get(index = this.pos) {
	return this.store[index];
}
\end{lstlisting}

\paragraph{indexOf(item) - Gibt den Index wo das gesuchte Element zuerst vorkommt} Diese Funktion kann nur auf primitive Typen, wie \lstinline|String|, \lstinline|Number|, \lstinline|Boolean|, usw. angewandt werden. Wir verwenden dazu die native \lstinline|indexOf()| Funktion von JS.
\begin{lstlisting}[caption=Array Konstruktor]
indexOf(item) {
	return this.store.indexOf(item);
}
\end{lstlisting}

\paragraph{lastIndexOf(item) - Gibt den Index wo das gesuchte Element zuletzt vorkommt} Auch diese Funktion kann nur auf primitive Typen, wie \lstinline|String|, \lstinline|Number|, \lstinline|Boolean|, usw. angewandt werden. Wir verwenden dazu die native \mbox{\lstinline|indexOf()|} Funktion von JS.
\begin{lstlisting}[caption=Array Konstruktor]
lastIndexOf(item) {
	return this.store.lastIndexOf(item);
}
\end{lstlisting}

\paragraph{isEmpty() - Liefert true, wenn die Liste leer ist} 
\begin{lstlisting}[caption=Array Konstruktor]
isEmpty() {
	return this.store.length === 0;
}
\end{lstlisting}
Hier vergleichen wir die Größe des Arrays mit der Zahl 0. Alternativ hätten wir auch \lstinline|return Boolean(this.store.length)| schreiben können. Jedoch finde ich die obige Version deklarativer. Dies ist manchmal viel wichtiger als kurzer oder prägnanter Code, weil wir den Code nicht für die Maschine schreiben, sondern für andere Entwickler.

\paragraph{insert(el, index) - Fügt ein Element an einer bestimmten Stelle ein} 
\begin{lstlisting}[caption=Array Konstruktor]
insert(el, index) {
	this.store.splice(index, 0, el);
}
\end{lstlisting}

\paragraph{add(el) - Fügt ein Element am Ende der Liste}
\begin{lstlisting}[caption=Array Konstruktor]
add(el) {
	this.store.push(el);
}
\end{lstlisting}
\paragraph{remove(index) - Entfernt ein Element an einer bestimmten Stelle}
\begin{lstlisting}[caption=Array Konstruktor]
remove(index) {
	this.store.splice(index, 1);
}
\end{lstlisting}
\paragraph{front() - Setzt die Position am Listenanfang}
\begin{lstlisting}[caption=Array Konstruktor]
remove(index) {
	this.pos = 0;
}
\end{lstlisting}
\paragraph{end() - Setzt die Position am Listenende}
\begin{lstlisting}[caption=Array Konstruktor]
end() {
	this.pos = this.store.length - 1;
}
\end{lstlisting}

\paragraph{prev() - Setzt die Position um eins nach vorne}
\begin{lstlisting}[caption=Array Konstruktor]
prev() {
	if (this.pos === 0) {
		return 0;
	}
	return --this.pos;
}
\end{lstlisting}
\paragraph{next() - Setzt die Position um eins nach hinten}
\begin{lstlisting}[caption=Array Konstruktor]
next() {
	if (this.pos === this.store.length - 1) {
		return this.pos;
	}
	return ++this.pos;
}
\end{lstlisting}
\paragraph{moveTo(index) - Setzt die Position an einer bestimmten Stelle}
\begin{lstlisting}[caption=Array Konstruktor]
moveTo(index) {
	if (this.pos === this.store.length - 1 
		|| this.pos === 0) {
		return;
	}
	this.pos = index;
}
\end{lstlisting}
\paragraph{sublist(from, to) - Erstellt eine Liste von (inklusive) einer bestimmten Stelle bis (exklusiv) eine bestimmten Stelle ohne das original Array zu ändern} Die Funktion \lstinline|slice()| bietet sich dafür besonders gut an, da sie genau eine subliste nach genau den genannten Parametern erstellt und dabei das original Array nicht verändert.
\begin{lstlisting}[caption=Array Konstruktor]
sublist(from, to) {
	return this.store.slice(from, to);
}

\end{lstlisting}
\section{Stack}
Ein Stack ist wie ein Stapel von Papier. Man legt ein Blatt Papier oben auf den Stapel auf und wenn man eins wegnehmen will, dann kann man dieses nur von oben entfernen. Dieses Prinzip nennt sich "Last-in-first-out" (LIFO). Viele Funktionen des \lstinline|Stacks| werden genauso implementiert wie bei der \lstinline|List|. Daher werde ich hier nur die Funktonen beschreiben, die ich bisher noch nicht implementiert habe. Für die komplette Implementierung siehe mein Repo inklusive Test.

Der Funktionsumfang eines \lstinline|Stack|, schaut folgendermaßen aus:

\begin{itemize} 
	\item push(item): Current position in list
	\item pop (property): Returns the number of elements in list	
	\item peek (function): Clears all elements from list
	\item empty (function): Returns string representation of list
	\item search(el)
\end{itemize}

push
public E push(E item)
Pushes an item onto the top of this stack. This has exactly the same effect as:
addElement(item)
Parameters:
item - the item to be pushed onto this stack.
Returns:
the item argument.
See Also:
Vector.addElement(E)
pop
public E pop()
Removes the object at the top of this stack and returns that object as the value of this function.
Returns:
The object at the top of this stack (the last item of the Vector object).
Throws:
EmptyStackException - if this stack is empty.
peek
public E peek()
Looks at the object at the top of this stack without removing it from the stack.
Returns:
the object at the top of this stack (the last item of the Vector object).
Throws:
EmptyStackException - if this stack is empty.
empty
public boolean empty()
Tests if this stack is empty.
Returns:
true if and only if this stack contains no items; false otherwise.
search
public int search(Object o)
Returns the 1-based position where an object is on this stack. If the object o occurs as an item in this stack, this method returns the distance from the top of the stack of the occurrence nearest the top of the stack; the topmost item on the stack is considered to be at distance 1. The equals method is used to compare o to the items in this stack.
Parameters:
o - the desired object.
Returns:
the 1-based position from the top of the stack where the object is located; the return value -1 indicates that the object is not on the stack.

\section{Queue}
\begin{itemize} 
	\item add
	boolean add(E e)
	Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
	Specified by:
	add in interface Collection<E>
	Parameters:
	e - the element to add
	Returns:
	true (as specified by Collection.add(E))
	Throws:
	IllegalStateException - if the element cannot be added at this time due to capacity restrictions
	ClassCastException - if the class of the specified element prevents it from being added to this queue
	NullPointerException - if the specified element is null and this queue does not permit null elements
	IllegalArgumentException - if some property of this element prevents it from being added to this queue
	
	\item offer
	boolean offer(E e)
	Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add(E), which can fail to insert an element only by throwing an exception.
	Parameters:
	e - the element to add
	Returns:
	true if the element was added to this queue, else false
	Throws:
	ClassCastException - if the class of the specified element prevents it from being added to this queue
	NullPointerException - if the specified element is null and this queue does not permit null elements
	IllegalArgumentException - if some property of this element prevents it from being added to this queue
	
	\item remove
	E remove()
	Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty.
	Returns:
	the head of this queue
	Throws:
	NoSuchElementException - if this queue is empty
	
	\item poll
	E poll()
	Retrieves and removes the head of this queue, or returns null if this queue is empty.
	Returns:
	the head of this queue, or null if this queue is empty
	element
	E element()
	Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty.
	Returns:
	the head of this queue
	Throws:
	NoSuchElementException - if this queue is empty
	
	\item addFirst
	void addFirst(E e)
	Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted deque, it is generally preferable to use method offerFirst(E).
	Parameters:
	e - the element to add
	Throws:
	IllegalStateException - if the element cannot be added at this time due to capacity restrictions
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item peek
	E peek()
	Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
	Returns:
	the head of this queue, or null if this queue is empty
	
\end{itemize}

Method Detail
\section{Dequeue}


\begin{itemize} 
	\item addLast
	void addLast(E e)
	Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted deque, it is generally preferable to use method offerLast(E).
	This method is equivalent to add(E).
	
	Parameters:
	e - the element to add
	Throws:
	IllegalStateException - if the element cannot be added at this time due to capacity restrictions
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item offerFirst
	boolean offerFirst(E e)
	Inserts the specified element at the front of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addFirst(E) method, which can fail to insert an element only by throwing an exception.
	Parameters:
	e - the element to add
	Returns:
	true if the element was added to this deque, else false
	Throws:
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item offerLast
	boolean offerLast(E e)
	Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addLast(E) method, which can fail to insert an element only by throwing an exception.
	Parameters:
	e - the element to add
	Returns:
	true if the element was added to this deque, else false
	Throws:
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item removeFirst
	E removeFirst()
	Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
	Returns:
	the head of this deque
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item removeLast
	E removeLast()
	Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
	Returns:
	the tail of this deque
	Throws:
	NoSuchElementException - if this deque is empty
	pollFirst
	E pollFirst()
	Retrieves and removes the first element of this deque, or returns null if this deque is empty.
	Returns:
	the head of this deque, or null if this deque is empty
	
	\item pollLast
	E pollLast()
	Retrieves and removes the last element of this deque, or returns null if this deque is empty.
	Returns:
	the tail of this deque, or null if this deque is empty
	
	\item getFirst
	E getFirst()
	Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
	Returns:
	the head of this deque
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item getLast
	E getLast()
	Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
	Returns:
	the tail of this deque
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item peekFirst
	E peekFirst()
	Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
	Returns:
	the head of this deque, or null if this deque is empty
	
	\item peekLast
	E peekLast()
	Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
	Returns:
	the tail of this deque, or null if this deque is empty
	
	\item removeFirstOccurrence
	boolean removeFirstOccurrence(Object o)
	Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
	Parameters:
	o - element to be removed from this deque, if present
	Returns:
	true if an element was removed as a result of this call
	Throws:
	ClassCastException - if the class of the specified element is incompatible with this deque (optional)
	NullPointerException - if the specified element is null and this deque does not permit null elements (optional)
	
	\item removeLastOccurrence
	boolean removeLastOccurrence(Object o)
	Removes the last occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
	Parameters:
	o - element to be removed from this deque, if present
	Returns:
	true if an element was removed as a result of this call
	Throws:
	ClassCastException - if the class of the specified element is incompatible with this deque (optional)
	NullPointerException - if the specified element is null and this deque does not permit null elements (optional)
	
	\item add
	boolean add(E e)
	Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offer.
	This method is equivalent to addLast(E).
	
	Specified by:
	add in interface Collection<E>
	Specified by:
	add in interface Queue<E>
	Parameters:
	e - the element to add
	Returns:
	true (as specified by Collection.add(E))
	Throws:
	IllegalStateException - if the element cannot be added at this time due to capacity restrictions
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item offer
	boolean offer(E e)
	Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the add(E) method, which can fail to insert an element only by throwing an exception.
	This method is equivalent to offerLast(E).
	
	Specified by:
	offer in interface Queue<E>
	Parameters:
	e - the element to add
	Returns:
	true if the element was added to this deque, else false
	Throws:
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item remove
	E remove()
	Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty.
	This method is equivalent to removeFirst().
	
	Specified by:
	remove in interface Queue<E>
	Returns:
	the head of the queue represented by this deque
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item poll
	E poll()
	Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty.
	This method is equivalent to pollFirst().
	
	Specified by:
	poll in interface Queue<E>
	Returns:
	the first element of this deque, or null if this deque is empty
	element
	E element()
	Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty.
	This method is equivalent to getFirst().
	
	Specified by:
	element in interface Queue<E>
	Returns:
	the head of the queue represented by this deque
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item peek
	E peek()
	Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty.
	This method is equivalent to peekFirst().
	
	Specified by:
	peek in interface Queue<E>
	Returns:
	the head of the queue represented by this deque, or null if this deque is empty
	
	\item push
	void push(E e)
	Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
	This method is equivalent to addFirst(E).
	
	Parameters:
	e - the element to push
	Throws:
	IllegalStateException - if the element cannot be added at this time due to capacity restrictions
	ClassCastException - if the class of the specified element prevents it from being added to this deque
	NullPointerException - if the specified element is null and this deque does not permit null elements
	IllegalArgumentException - if some property of the specified element prevents it from being added to this deque
	
	\item pop
	E pop()
	Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque.
	This method is equivalent to removeFirst().
	
	Returns:
	the element at the front of this deque (which is the top of the stack represented by this deque)
	Throws:
	NoSuchElementException - if this deque is empty
	
	\item remove
	boolean remove(Object o)
	Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
	This method is equivalent to removeFirstOccurrence(java.lang.Object).
	
	Specified by:
	remove in interface Collection<E>
	Parameters:
	o - element to be removed from this deque, if present
	Returns:
	true if an element was removed as a result of this call
	Throws:
	ClassCastException - if the class of the specified element is incompatible with this deque (optional)
	NullPointerException - if the specified element is null and this deque does not permit null elements (optional)
	
	\item contains
	boolean contains(Object o)
	Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e)).
	Specified by:
	contains in interface Collection<E>
	Parameters:
	o - element whose presence in this deque is to be tested
	Returns:
	true if this deque contains the specified element
	Throws:
	ClassCastException - if the type of the specified element is incompatible with this deque (optional)
	NullPointerException - if the specified element is null and this deque does not permit null elements (optional)
	
	\item size
	int size()
	Returns the number of elements in this deque.
	Specified by:
	size in interface Collection<E>
	Returns:
	the number of elements in this deque
	
	\item iterator
	Iterator<E> iterator()
	Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail).
	Specified by:
	iterator in interface Collection<E>
	Specified by:
	iterator in interface Iterable<E>
	Returns:
	an iterator over the elements in this deque in proper sequence
	
	\item descendingIterator
	Iterator<E> descendingIterator()
	Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
	Returns:
	an iterator over the elements in this deque in reverse sequence
	
\end{itemize}

Method Detail
\section{Priority Queue}
Method Detail
add
public boolean add(E e)
Inserts the specified element into this priority queue.
Specified by:
add in interface Collection<E>
Specified by:
add in interface Queue<E>
Overrides:
add in class AbstractQueue<E>
Parameters:
e - the element to add
Returns:
true (as specified by Collection.add(E))
Throws:
ClassCastException - if the specified element cannot be compared with elements currently in this priority queue according to the priority queue's ordering
NullPointerException - if the specified element is null
offer
public boolean offer(E e)
Inserts the specified element into this priority queue.
Specified by:
offer in interface Queue<E>
Parameters:
e - the element to add
Returns:
true (as specified by Queue.offer(E))
Throws:
ClassCastException - if the specified element cannot be compared with elements currently in this priority queue according to the priority queue's ordering
NullPointerException - if the specified element is null
peek
public E peek()
Description copied from interface: Queue
Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
Specified by:
peek in interface Queue<E>
Returns:
the head of this queue, or null if this queue is empty
remove
public boolean remove(Object o)
Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
Specified by:
remove in interface Collection<E>
Overrides:
remove in class AbstractCollection<E>
Parameters:
o - element to be removed from this queue, if present
Returns:
true if this queue changed as a result of the call
contains
public boolean contains(Object o)
Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
Specified by:
contains in interface Collection<E>
Overrides:
contains in class AbstractCollection<E>
Parameters:
o - object to be checked for containment in this queue
Returns:
true if this queue contains the specified element
toArray
public Object[] toArray()
Returns an array containing all of the elements in this queue. The elements are in no particular order.
The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.

This method acts as bridge between array-based and collection-based APIs.

Specified by:
toArray in interface Collection<E>
Overrides:
toArray in class AbstractCollection<E>
Returns:
an array containing all of the elements in this queue
toArray
public <T> T[] toArray(T[] a)
Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue.
If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to null.

Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs.

Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:

String[] y = x.toArray(new String[0]);
Note that toArray(new Object[0]) is identical in function to toArray().
Specified by:
toArray in interface Collection<E>
Overrides:
toArray in class AbstractCollection<E>
Parameters:
a - the array into which the elements of the queue are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose.
Returns:
an array containing all of the elements in this queue
Throws:
ArrayStoreException - if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue
NullPointerException - if the specified array is null
iterator
public Iterator<E> iterator()
Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order.
Specified by:
iterator in interface Iterable<E>
Specified by:
iterator in interface Collection<E>
Specified by:
iterator in class AbstractCollection<E>
Returns:
an iterator over the elements in this queue
size
public int size()
Description copied from interface: Collection
% Returns the number of elements in this collection. If this collection contains more than "Integer.MAX_VALUE" elements, returns "Integer.MAX_VALUE".
Specified by:
size in interface Collection<E>
Specified by:
size in class AbstractCollection<E>
Returns:
the number of elements in this collection
clear
public void clear()
Removes all of the elements from this priority queue. The queue will be empty after this call returns.
Specified by:
clear in interface Collection<E>
Overrides:
clear in class AbstractQueue<E>
poll
public E poll()
Description copied from interface: Queue
Retrieves and removes the head of this queue, or returns null if this queue is empty.
Specified by:
poll in interface Queue<E>
Returns:
the head of this queue, or null if this queue is empty
comparator
public Comparator<? super E> comparator()
Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements.
Returns:
the comparator used to order this queue, or null if this queue is sorted according to the natural ordering of its elements
\section{LinkedList}
Method Detail
getFirst
public E getFirst()
Returns the first element in this list.
Specified by:
getFirst in interface Deque<E>
Returns:
the first element in this list
Throws:
NoSuchElementException - if this list is empty
getLast
public E getLast()
Returns the last element in this list.
Specified by:
getLast in interface Deque<E>
Returns:
the last element in this list
Throws:
NoSuchElementException - if this list is empty
removeFirst
public E removeFirst()
Removes and returns the first element from this list.
Specified by:
removeFirst in interface Deque<E>
Returns:
the first element from this list
Throws:
NoSuchElementException - if this list is empty
removeLast
public E removeLast()
Removes and returns the last element from this list.
Specified by:
removeLast in interface Deque<E>
Returns:
the last element from this list
Throws:
NoSuchElementException - if this list is empty
addFirst
public void addFirst(E e)
Inserts the specified element at the beginning of this list.
Specified by:
addFirst in interface Deque<E>
Parameters:
e - the element to add
addLast
public void addLast(E e)
Appends the specified element to the end of this list.
This method is equivalent to add(E).

Specified by:
addLast in interface Deque<E>
Parameters:
e - the element to add
contains
public boolean contains(Object o)
Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
Specified by:
contains in interface Collection<E>
Specified by:
contains in interface Deque<E>
Specified by:
contains in interface List<E>
Overrides:
contains in class AbstractCollection<E>
Parameters:
o - element whose presence in this list is to be tested
Returns:
true if this list contains the specified element
size
public int size()
Returns the number of elements in this list.
Specified by:
size in interface Collection<E>
Specified by:
size in interface Deque<E>
Specified by:
size in interface List<E>
Specified by:
size in class AbstractCollection<E>
Returns:
the number of elements in this list
add
public boolean add(E e)
Appends the specified element to the end of this list.
This method is equivalent to addLast(E).

Specified by:
add in interface Collection<E>
Specified by:
add in interface Deque<E>
Specified by:
add in interface List<E>
Specified by:
add in interface Queue<E>
Overrides:
add in class AbstractList<E>
Parameters:
e - element to be appended to this list
Returns:
true (as specified by Collection.add(E))
remove
public boolean remove(Object o)
Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
Specified by:
remove in interface Collection<E>
Specified by:
remove in interface Deque<E>
Specified by:
remove in interface List<E>
Overrides:
remove in class AbstractCollection<E>
Parameters:
o - element to be removed from this list, if present
Returns:
true if this list contained the specified element
addAll
public boolean addAll(Collection<? extends E> c)
Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
Specified by:
addAll in interface Collection<E>
Specified by:
addAll in interface List<E>
Overrides:
addAll in class AbstractCollection<E>
Parameters:
c - collection containing elements to be added to this list
Returns:
true if this list changed as a result of the call
Throws:
NullPointerException - if the specified collection is null
See Also:
AbstractCollection.add(Object)
addAll
public boolean addAll(int index,
Collection<? extends E> c)
Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
Specified by:
addAll in interface List<E>
Overrides:
addAll in class AbstractSequentialList<E>
Parameters:
index - index at which to insert the first element from the specified collection
c - collection containing elements to be added to this list
Returns:
true if this list changed as a result of the call
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index > size())
NullPointerException - if the specified collection is null
clear
public void clear()
Removes all of the elements from this list. The list will be empty after this call returns.
Specified by:
clear in interface Collection<E>
Specified by:
clear in interface List<E>
Overrides:
clear in class AbstractList<E>
get
public E get(int index)
Returns the element at the specified position in this list.
Specified by:
get in interface List<E>
Overrides:
get in class AbstractSequentialList<E>
Parameters:
index - index of the element to return
Returns:
the element at the specified position in this list
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index >= size())
set
public E set(int index,
E element)
Replaces the element at the specified position in this list with the specified element.
Specified by:
set in interface List<E>
Overrides:
set in class AbstractSequentialList<E>
Parameters:
index - index of the element to replace
element - element to be stored at the specified position
Returns:
the element previously at the specified position
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index >= size())
add
public void add(int index,
E element)
Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
Specified by:
add in interface List<E>
Overrides:
add in class AbstractSequentialList<E>
Parameters:
index - index at which the specified element is to be inserted
element - element to be inserted
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index > size())
remove
public E remove(int index)
Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
Specified by:
remove in interface List<E>
Overrides:
remove in class AbstractSequentialList<E>
Parameters:
index - the index of the element to be removed
Returns:
the element previously at the specified position
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index >= size())
indexOf
public int indexOf(Object o)
Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
Specified by:
indexOf in interface List<E>
Overrides:
indexOf in class AbstractList<E>
Parameters:
o - element to search for
Returns:
the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element
lastIndexOf
public int lastIndexOf(Object o)
Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
Specified by:
lastIndexOf in interface List<E>
Overrides:
lastIndexOf in class AbstractList<E>
Parameters:
o - element to search for
Returns:
the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element
peek
public E peek()
Retrieves, but does not remove, the head (first element) of this list.
Specified by:
peek in interface Deque<E>
Specified by:
peek in interface Queue<E>
Returns:
the head of this list, or null if this list is empty
Since:
1.5
element
public E element()
Retrieves, but does not remove, the head (first element) of this list.
Specified by:
element in interface Deque<E>
Specified by:
element in interface Queue<E>
Returns:
the head of this list
Throws:
NoSuchElementException - if this list is empty
Since:
1.5
poll
public E poll()
Retrieves and removes the head (first element) of this list.
Specified by:
poll in interface Deque<E>
Specified by:
poll in interface Queue<E>
Returns:
the head of this list, or null if this list is empty
Since:
1.5
remove
public E remove()
Retrieves and removes the head (first element) of this list.
Specified by:
remove in interface Deque<E>
Specified by:
remove in interface Queue<E>
Returns:
the head of this list
Throws:
NoSuchElementException - if this list is empty
Since:
1.5
offer
public boolean offer(E e)
Adds the specified element as the tail (last element) of this list.
Specified by:
offer in interface Deque<E>
Specified by:
offer in interface Queue<E>
Parameters:
e - the element to add
Returns:
true (as specified by Queue.offer(E))
Since:
1.5
offerFirst
public boolean offerFirst(E e)
Inserts the specified element at the front of this list.
Specified by:
offerFirst in interface Deque<E>
Parameters:
e - the element to insert
Returns:
true (as specified by Deque.offerFirst(E))
Since:
1.6
offerLast
public boolean offerLast(E e)
Inserts the specified element at the end of this list.
Specified by:
offerLast in interface Deque<E>
Parameters:
e - the element to insert
Returns:
true (as specified by Deque.offerLast(E))
Since:
1.6
peekFirst
public E peekFirst()
Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
Specified by:
peekFirst in interface Deque<E>
Returns:
the first element of this list, or null if this list is empty
Since:
1.6
peekLast
public E peekLast()
Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
Specified by:
peekLast in interface Deque<E>
Returns:
the last element of this list, or null if this list is empty
Since:
1.6
pollFirst
public E pollFirst()
Retrieves and removes the first element of this list, or returns null if this list is empty.
Specified by:
pollFirst in interface Deque<E>
Returns:
the first element of this list, or null if this list is empty
Since:
1.6
pollLast
public E pollLast()
Retrieves and removes the last element of this list, or returns null if this list is empty.
Specified by:
pollLast in interface Deque<E>
Returns:
the last element of this list, or null if this list is empty
Since:
1.6
push
public void push(E e)
Pushes an element onto the stack represented by this list. In other words, inserts the element at the front of this list.
This method is equivalent to addFirst(E).

Specified by:
push in interface Deque<E>
Parameters:
e - the element to push
Since:
1.6
pop
public E pop()
Pops an element from the stack represented by this list. In other words, removes and returns the first element of this list.
This method is equivalent to removeFirst().

Specified by:
pop in interface Deque<E>
Returns:
the element at the front of this list (which is the top of the stack represented by this list)
Throws:
NoSuchElementException - if this list is empty
Since:
1.6
removeFirstOccurrence
public boolean removeFirstOccurrence(Object o)
Removes the first occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
Specified by:
removeFirstOccurrence in interface Deque<E>
Parameters:
o - element to be removed from this list, if present
Returns:
true if the list contained the specified element
Since:
1.6
removeLastOccurrence
public boolean removeLastOccurrence(Object o)
Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
Specified by:
removeLastOccurrence in interface Deque<E>
Parameters:
o - element to be removed from this list, if present
Returns:
true if the list contained the specified element
Since:
1.6
listIterator
public ListIterator<E> listIterator(int index)
Returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list. Obeys the general contract of List.listIterator(int).
The list-iterator is fail-fast: if the list is structurally modified at any time after the Iterator is created, in any way except through the list-iterator's own remove or add methods, the list-iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.

Specified by:
listIterator in interface List<E>
Specified by:
listIterator in class AbstractSequentialList<E>
Parameters:
index - index of the first element to be returned from the list-iterator (by a call to next)
Returns:
a ListIterator of the elements in this list (in proper sequence), starting at the specified position in the list
Throws:
IndexOutOfBoundsException - if the index is out of range (index < 0 || index > size())
See Also:
List.listIterator(int)
descendingIterator
public Iterator<E> descendingIterator()
Description copied from interface: Deque
Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
Specified by:
descendingIterator in interface Deque<E>
Returns:
an iterator over the elements in this deque in reverse sequence
Since:
1.6
clone
public Object clone()
Returns a shallow copy of this LinkedList. (The elements themselves are not cloned.)
Overrides:
clone in class Object
Returns:
a shallow copy of this LinkedList instance
See Also:
Cloneable
toArray
public Object[] toArray()
Returns an array containing all of the elements in this list in proper sequence (from first to last element).
The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array.

This method acts as bridge between array-based and collection-based APIs.

Specified by:
toArray in interface Collection<E>
Specified by:
toArray in interface List<E>
Overrides:
toArray in class AbstractCollection<E>
Returns:
an array containing all of the elements in this list in proper sequence
See Also:
Arrays.asList(Object[])
toArray
public <T> T[] toArray(T[] a)
Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list.
If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.)

Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs.

Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:

String[] y = x.toArray(new String[0]);
Note that toArray(new Object[0]) is identical in function to toArray().
Specified by:
toArray in interface Collection<E>
Specified by:
toArray in interface List<E>
Overrides:
toArray in class AbstractCollection<E>
Parameters:
a - the array into which the elements of the list are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose.
Returns:
an array containing the elements of the list
Throws:
ArrayStoreException - if the runtime type of the specified array is not a supertype of the runtime type of every element in this list
NullPointerException - if the specified array is null
\section{Zirkulare LinkedList}
\section{Zweifach verknüpfte LinkedList}
\section{Dictionary}
\section{Hashing}
\section{HashMap}
\section{MapTree}
\section{LinkedMap}
\section{Sets}
\section{Binäre Bäume}
\section{Graphen}
\section{AVL Tree}

\chapter{Algorithmen}
Sortier Algorithmen und Such Algorithmen
\section{Breitensuche}
\section{Tiefensuche}
\section{Bubble Sort}
\section{Selection Sort}
\section{Shellsort}
\section{Mergesort}
\section{Quicksort}
\section{Sequential Suche}
\section{Binäres Suchen}
\section{Suchen nach Minimum und Maximum}
\section{Rucksackproblem}
\section{Greedy Algorithm}
\chapter{Aufgaben}
\section{Binäres Suchen}
\begin{examplei}
Gegeben ist ein Array mit ganzen Zahlen. Gib den Index des gegebenen Keys. Falls kein Ergebnis gefunden wurde, gib \lstinline|-1| zurück.

Beispiel:
Gegeben ist folgender Array, wenn der Key 47 ist, dann soll die Binäre Suche 2 zurückgeben.


	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index     & 0 & 1 & 2 & 3 & 4 & 5  & 6  & 7  & 8  & 9 \\ 
		\hline
		Key & 23 & 31 & 47	  & 65 & 69 & 73 & 75 & 89 & 91 & 93 \\
		\hline
	\end{tabular}

\end{examplei}
{\bf Stichwörter:} Array, Binary Search, Suche, Sliding Window, Zeiger, Pointer, Divide and Conquer, Teile und Herrsche
\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item Betrachte das Array von Anfang bis Ende
	\item Berechne den Index der in der Mitte liegt
	\item Wenn der Mitte Index genau auf den Key zeigt, dann gib den diesen Index zurück
	\item Wenn das Element an der Mitte Index kleiner ist als der Key, dann betrachte nur das Subarray von der Mitte Index bis zum Ende
	\item Wenn das Element an der Mitte Index größer ist als der Key, dann betrachte nur das Subarray von der Mitte Index bis zum Anfang
	\item Wiederhole die obigen Schritte solange bis das Subarray leer ist
\end{enumerate}

\paragraph{Typische Fehler}
\begin{lstlisting}[caption=My Javascript Example]
//a is sorted array
let binarySearch = function(a, key) {
	let newA = a;
	let currentIndex;
	while(newA.length !== 0) {
		currentIndex = newA.length / 2;
		const currentKey = newA[currentIndex];
	
		if (currentKey === key) {
			return currentIndex;
		} else if (currentKey < key) {
			newA = newA.(currentIndex);
		} else {
			newA = newA.slice(0, currentIndex + 1);
		}
	}
	return -1;
};
\end{lstlisting}

\begin{itemize} 
	\item Ein Array ist index basiert beginned bei 0
	
	Das weißt wahrscheinlich jeder bisher. Jedoch wird die Implikationen dessen sehr oft vergessen. Um auf den Index \lstinline|currentIndex| zu kommen muss die \lstinline|(arr.length - 1) / 2| genommen werden.
	\item Array Index sind immer ganze Zahlen
	
	Auch dies sollte mittlerweile bekannt sein. Doch wie im obigen Fall zu sehen wurde durch \lstinline|2| geteilt. Bei ungeraden Zahlen entstehen dadurch rationale Zahlen, die auf ganze Zahlen wieder zurück gecastet werden müssen
	
	\item Es wird nach dem Index des original Arrays gefragt
	
	Ein neues Array zu erstellen und darauf den Index zu ermitteln bedeutet, dass man den Index des neuen Arrays zurück gibt. Gesucht ist aber der Index des gegebenen Arrays
	\item \lstinline|currentIndex| nicht wiederholt überprüfen
	
	Selbst wenn es möglich sein sollte das original Array in Stücke so zu teilen dass dennoch die original Index beizubehalten, ist die Auswahl der Indexe falsch, denn \lstinline|currentIndex| wurde bereits geprüft. Es ist daher unsinnig, dass dieser Index noch im Subarray erscheint. Man müsste also \lstinline|currentIndex + 1| für \lstinline|currentKey < key| bzw. \lstinline|curentIndex| (\lstinline|currentIndex| selbst wird also nicht betrachtet) für \lstinline|currentKey > key| wählen.
	
	\item Programm liefert kein Ergebnis
	
	Das Programm läuft in Endlosschleife und kann somit kein Ergebnis liefern.
	
\end{itemize}
\paragraph{Lösung}
Wir versuchen immer am Anfang einen "early exit" zu erreichen, damit der Code effizient bleibt. Alternativ hätte man auch \lstinline|includes()| verwenden können. Aber \lstinline|includes()| geht durch alle Array Elemente durch und hätte damit eine Laufzeit von \lstinline|O(n)|. 

Wir erreichen einen "early exit", indem wir überprüfen, ob das Array keine Elemente enthält oder ein Element. Bei keinem Element geben wir sofort \lstinline|-1| zurück. Wenn ein Element vorhanden ist können wir gleich überprüfen, ob dieses Element dem \lstinline|key| entspricht. Falls ja, geben wir \lstinline|0| zurück, falls nicht, ist es nicht vorhanden und wir geben \lstinline|-1| zurück.

Die Vorgehensweise ist ähnlich wie oben beschrieben. Wir werden aber zwei Zeiger benutzen. Dadurch bleiben die Indexe immer die der originalen Arrays.

Die Laufzeit

Zeit komplexität

\begin{lstlisting}[caption=My Javascript Example]
//a is sorted array
let binarySearch = function(a, key) {
	if (a.length === 0) {
		return -1;
	}
	if (a.length === 1) {
		return a[0] === key ? 0 : -1;
	}
	let startIndex = 0;
	let endIndex = a.length - 1;
	while(startIndex <= endIndex) {
		const currentIndex = (startIndex + endIndex) / 2 | 0;
		const currentKey = a[currentIndex];
		if (currentKey === key) {
			return currentIndex;
		} else if (currentKey < key) {
			startIndex = currentIndex + 1;
		} else {
			endIndex = currentIndex - 1;
		}
	}
	return -1;
};
\end{lstlisting}

\begin{examplei}
	Gegeben ist ein Array mit sortierten Zahlen, die keine Duplikate enthält. Dieses Array ähnelt dem Array in der Aufgabe darüber. Der Unterschied hier ist, dass dieses Array um eine zufällige Stellenanzahl verschoben wurde. Es soll eine Zahl darin gefunden und dessen Index zurückgegeben werden. Falls sie nicht existiert, dann soll \lstinline|-1| zurück gegeben werden. Die Lösung muss schneller als lineare Laufzeit sein.
	
	Beispiel:
	Wir nehmen das Beispiel aus der vorherigen Aufgabe.
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index & \cellcolor{yellow!25}0 & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}2 & \cellcolor{yellow!25}3 & \cellcolor{yellow!25}4 & \cellcolor{yellow!25}5  & \cellcolor{yellow!25}6  & \cellcolor{yellow!25}7  & \cellcolor{yellow!25}8  & \cellcolor{yellow!25}9 \\ 
		\hline
		Key & \cellcolor{blue!25}23 & \cellcolor{blue!25}31 & \cellcolor{blue!25}47 & \cellcolor{blue!25}65 & \cellcolor{blue!25}69 & \cellcolor{blue!25}73 & \cellcolor{blue!25}75 & \cellcolor{blue!25}89 & \cellcolor{blue!25}91 & \cellcolor{blue!25}93 \\
		\hline
	\end{tabular}
	
	Dieses Array verschieben wir um drei Stellen nach rechts:
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index & \cellcolor{yellow!25}0 & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}2 & \cellcolor{yellow!25}3 & \cellcolor{yellow!25}4 & \cellcolor{yellow!25}5  & \cellcolor{yellow!25}6  & \cellcolor{yellow!25}7  & \cellcolor{yellow!25}8  & \cellcolor{yellow!25}9 \\ 
		\hline
		Key & \cellcolor{green!25}89 & \cellcolor{green!25}91 & \cellcolor{green!25}93 & \cellcolor{blue!25}23 & \cellcolor{blue!25}31 & \cellcolor{blue!25}47 & \cellcolor{blue!25}65 & \cellcolor{blue!25}69 & \cellcolor{blue!25}73 & \cellcolor{blue!25}75 \\
		\hline
	\end{tabular}

Hier ist die gesuchte Antwort \lstinline|5|, weil \lstinline|47| am Index \lstinline|5| ist.	
\end{examplei}

{\bf Stichwörter:} Array, Binary Search, Suche, Sliding Window, Zeiger, Pointer, Divide and Conquer, Teile und Herrsche
\paragraph{Vorgehensweise}
Ansätze um zuerst die Sollbruchstelle zu finden sind zu aufwändig.

\begin{enumerate} 
	\item Wir versuchen folgende Fälle zu berücksichtigen:
	\begin{itemize} 
		\item Element, das 
		
	\end{itemize}
	Ermittelt den Wert in der Mitte des Arrays
	
	
	\item Teile ihn dann in zwei Arrays auf
	\item Suche in jeweils der zwei Subarrays nach der Zahl in Binary Search
\end{enumerate}

\paragraph{Typische Fehler}
\begin{lstlisting}[caption=My Javascript Example]
let binarySearchSwitched = function(arr, key) {
	const maxIndex = arr.length - 1;
	let startPointer = 0;
	let endPointer = maxIndex;
	while (startPointer <= endPointer) {
		const currentPointer = (startPointer + endPointer) / 2 | 0;
		const oldCurrentKey = arr[currentPointer];
		
		if (oldCurrentKey < key) {
			// go to right
			startPointer = currentPointer + 1;
			const newCurrentPointer = (startPointer + endPointer) / 2;
			const newCurrentKey = arr[newCurrentPointer];
			if (newCurrentKey < oldCurrentKey) {
				// we are on the right; newCurrentKey has to be bigger than oldCurrentKey
				// if it is not, then we have to look at the other side
				return searchBinay(0, currentPointer - 1);
			}
		} else if (oldCurrentKey > key) {
			// go to left
			endPointer = currentPointer - 1;
			const newCurrentPointer = (startPointer + endPointer) / 2;
			const newCurrentKey = arr[newCurrentPointer];
			if (newCurrentKey > oldCurrentKey) {
				// we are on the left; newCurrentKey has to be smaller than oldCurrentKey
				// if it is not, then we have to look at the other side
				return searchBinay(currentPointer + 1, maxIndex);
			}
		} else {
			return currentPointer;
		}
	
		// search reaches end
		if (startPointer > maxIndex || endPointer > maxIndex) {
			return searchBinary(0, maxIndex / 2 | 0);
		}
		// search reaches start
		if (startPointer < 0 || endPointer < 0 ) {
			return searchBinary(maxIndex / 2 | 0, maxIndex);
		}
	}

	function searchBinary(start, end) {
		while (start <= end) {
			const currentPointer = (start + end) / 2 | 0;
			const oldCurrentKey = arr[currentPointer];
			if (oldCurrentKey < key) {
				// go to right
				start = currentPointer + 1;
			} else if (oldCurrentKey > key) {
				// go to left
				end = currentPointer - 1;
			} else {
				return currentPointer;
			}
		}
		return -1;
	}
};
\end{lstlisting}

\begin{itemize} 
	\item Zu lang, zu kompliziert und zu spezifisch
	
	Die Länge des Codes ist geschuldet durch die Tatsache, dass im Code spezifisch auf viele mögliche Fälle (Es wird das bzw. den Ende/Anfang erreicht ohne das Element gefunden zu haben; das neue Element ist außerhalb der Kontinuität der Reihe) eingegangn wird und versucht wird diese durch viele \lstinline|if| Abfragen abzufangen. Normalerweise ist das schon ein erster Indiz, dafür dass diese Lösung nicht optimal ist. 
	
	\item Nutzt vorhandene Informationen nicht
	
	Offensichtlich ist es wichtig zu wissen, wo der Schnitt sich befindet bzw. welche Elemente vor dem Schnitt sich befinden. Man hätte ausnutzen können, dass die Zahlen sortiert sind und dadurch die Elemente, die vor dem Schnitt sind damit erkennen können. Dies wurde im obigen Ansatz aber nicht berücksichtigt. Deshalb liefer er für folgendes Array und folgenden Key einen Fehler:
	
	 \lstinline|[17,18,19,20,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]| mit der gesuchten Zahl \lstinline|20|
	 
	 Obiger Ansatz gibt inkorrekterweise \lstinline|-1| zurück, obwohl \lstinline|3| erwartet worden wäre.
	
\end{itemize}
\paragraph{Lösung} Auf die Lösung zu kommen ist nicht sofort ersichtlich. Aber die Lösung zu dieser Aufgabe ist an sich recht einfach, wenn man sich folgende Dinge vergegenwärtigt:

Die Laufzeit

Zeit komplexität

\begin{lstlisting}[caption=My Javascript Example]
function keyInFirstHalfSortedArray(start, mid, key, arr) {
	return arr[start] < arr[mid] && arr[start] >= key && arr[mid] < key;
}
function keyInSecondHalfSortedArray(mid, end, key, arr) {
	return arr[mid] < arr[end] && arr[mid] < key && arr[end] >= key;
}
function keyInFirstHalfUnsortedArray (start, mid, key, arr) {
	return arr[start] > arr[mid] && arr[start] >= key || arr[mid] < key;
}
function keyInFirstHalfUnsortedArray(mid, end, key, arr) {
	return arr[mid] > arr[end] && arr[mid] > key || arr[end] <= key;
}
let binarySearchSwitched = function(arr, key) {
	const maxIndex = arr.length - 1;
	let startPointer = 0;
	let endPointer = maxIndex;

	while (startPointer <= endPointer) {
		const midPointer = (startPointer + endPointer) / 2 | 0;
		if (arr[midPointer] === key) {
			return midPointer;
		}
		if (keyInFirstHalfSortedArray(startPointer, midPointer, key, arr)) {
			endPointer = midPointer - 1;
		} else if (keyInSecondHalfSortedArray(midPointer, endPointer, key, arr)) {
			startPointer = midPointer + 1;
		} else if (keyInFirstHalfUnsortedArray(startPointer, midPointer, key, arr)) {
			endPointer = midPointer - 1;
		} else if (keyInFirstHalfUnsortedArray(midPointer, endPointer, key, arr)) {
			startPointer = midPointer + 1;
		} else {
			return -1;
		}
	}
	return -1;
};
\end{lstlisting}

Eine alternative Lösung wäre es Rekursion zu benutzen:
\begin{lstlisting}[caption=My Javascript Example]
let binarySearchRecursive = function(arr, st, end, key) {
	// assuming all the keys are unique.
	if (st > end) {
		return -1;
	}
	
	let mid = st + Math.floor((end - st) / 2);
	
	if (arr[mid] === key) {
		return mid;
	}
	
	if (arr[st] <= arr[mid] && key <= arr[mid] && key >= arr[st]) {
		return binary_search_recs(arr, st, mid - 1, key);
	} else if (arr[mid] <= arr[end] && key >= arr[mid] && key <= arr[end]) {
		return binary_search_recs(arr, mid + 1, end, key);
	} else if (arr[end] <= arr[mid]) {
		return binary_search_recs(arr, mid + 1, end, key);
	} else if (arr[st] >= arr[mid]) {
		return binary_search_recs(arr, st, mid - 1, key);
	} 
	
	return -1;
};

let binarySearchSwitched = function(arr, key) {
	return binarySearchRecursive(arr, 0, arr.length - 1, key);
};
\end{lstlisting}

JS ist jedoch schlecht für Rekursion ausgelegt, wie ich es in einen der vorherigen Kapitel beschrieben habe.
\section{Maximum im gleitenden Fenster}
\begin{examplei}
Gegeben ist ein langes Array mit ganzen Zahlen. Zudem ist noch ein Fenster mit einer Breite \lstinline|w| gegeben, das sich von Anfang bis Ende des Arrays bewegt. Finde alle Maxima, die im gleitenden Fenster auftauchen.

Beispiel:
Gegeben ist folgender Array mit einer Fensterbreite von \lstinline|4|. 	

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
\hline
3 & 23 & -31 & 47 & -65 & 69 \\
\hline
\end{tabular}
Das Fenster bewegt sich nun von links nach rechts und enthält folgende Zahlen:
\begin{enumerate}
\item Schritt

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
\hline
3 & 23 & -31 & 47 \\
\hline
\end{tabular}

Das Maximum ist \lstinline|47|
\item Schritt

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
\hline
23 & -31 & 47 & -65 \\
\hline
\end{tabular}

Das Maximum ist wieder \lstinline|47|	

\item Schritt
		
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
\hline
-31 & 47 & -65 & 69 \\
\hline
\end{tabular}

Das Maximum ist wieder \lstinline|69|
\end{enumerate}

Das erwartete Ergebnis ist in diesem Beispiel 
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
	\hline
	47 & 47 & 69 \\
	\hline
\end{tabular}

\end{examplei}
{\bf Stichwörter:} Array, Suche, Sliding Window, Zeiger, Pointer, Dequeue

\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item Wir erstellen zwei Zeiger
	
	Die Zeiger nennen wir startWindow und endWindow. startWindow wird mit \lstinline|0| und \lstinline|endWindow| wird mit \lstinline|array.length - 1| initialisiert. 
	
	\item Hilfsfunktion zur Berechnung des Maximums
	
	Wir erstellen noch eine Hilfsfunktion, die das Maximum für gegebenes \lstinline|startWindow| und \lstinline|endWindow| berechnet und in ein Resultat-Array hinzufügt.
	
	\item Iteration bis Arrayende
	
	Wir iterieren dann duch die verbleibenden Elemente und inkrementieren \lstinline|startWindow| und \lstinline|endWindow|. Dabei rufen wir jedesmal die Hilfsfunktion zur Berechnung des Maximums.
	
	\item Rückgabe
	
	Am Ende geben wir das Resultat-Array zurück
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]
const findMaxSlidingSindow = function(arr, window_size) {
	const getMax = (startWindow, endWindow) => {
		const max = arr
		.slice(startWindow, endWindow + 1)
		.reduce((max, item) => item > max ? item : max, -Infinity);
		result.push(max);
	}
	const result = [];
	let startWindow = 0;
	let endWindow = window_size - 1;
	while (endWindow < arr.length) {
		
		getMax(startWindow++, endWindow++);    
	}
	return result;
};
\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item Kein early exit verwendet
	
	Man sollte immer versuchen einen early exit zu verwenden, d.h. schauen, ob anhand einer einfachen überprüfung am Anfang gleich auf das richtige Ergebnis geschlossen werden kann. Beispw. muss man nichts berechnen, wenn das Array leer ist oder die gegebene Fensterbreite größer ist als das Array.
	
	\item Keine geeignete Datenstruktur verwendet
	
	Die Aufgabe bietet es sich an ein \lstinline|Dequeue| zu verwenden. Dadurch brauchen wir auch keine zwei Zeiger.
	
	\item Ungünstige Laufzeit
	
	Durch die Hilfsfunktion zur Berechnung des Maximums werden bereits besuchte Elemente erneut besucht. Bei einer kleinen Fensterbreite ist das kein großes Problem aber angenommen es handelt sich um ein langes Array mit einer sehr großen Fensterbreite. Dies führt zu einer langsamen Laufzeit. Das ist ein erster Hinweis, dass der vorliegende Code nicht optimal ist.

\end{itemize}

\paragraph{Lösung}
Die Schwierigkeit liegt darin, das Maximum zu finden ohne erneut die Zahlen im Fenster durchzugehen. Idealerweise wollen wir nur eimal durch die Zahlen im Array gehen und dabei das Maximum speichern. Nachfolgend werde ich begründen, warum eine \lstinline|Dequeue| die geeignete Datenstruktur ist.

Angenommen wir haben folgendes Array und eine Fensterbreite von \lstinline|3| und benutzen dazu wir zunächst eine Variable zur Speicherung des Maximums:

\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
	\hline
	7 & 6 & 2 & 4 & 1 & 7\\
	\hline
\end{tabular}

Wenn wir durch die einzelnen Arrays gehen und das Maximum jedesmal in der Variable speichern, würden wir folgendes Ergebnis bekommen:

\begin{enumerate} 
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		7 \\
		\hline
	\end{tabular} 

	Erste Zahl ist 7. Dadurch ist max auch 7
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		7 & 6 \\
		\hline
	\end{tabular} 

	Die 6 ist kleiner als das aktuelle max und daher ist max immer noch 7
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		7 & 6 & 2\\
		\hline
	\end{tabular} 
			
	Max bleibt nach der 2 immer noch bei 7. Dadurch haben wir die Fensterbreite erreicht. Das max ist für die erste Fensterbreite ist 7.
	
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		6 & 2 & 4\\
		\hline
	\end{tabular}  

	Ab jetzt bekommen wir eine konstante Anzahl an 3 Zahlen. Die 7 ist raus. Die 4 kommt rein. Das Maximum kann nun nicht mehr 7 sein. Aber was ist es stattdessen? Es kann nicht 4 sein. Es ist 6. Aber unser Ansatz hat keine Möglichkeit zu erkennen, dass es die 6 ist. 
\end{enumerate}

Was wir daher brauchen ist also keine Variable zur Speicherung des Maximums, sondern wir müssen eine Sequenz speichern. Wie wollen die Sequenz so speichern, dass die größere Zahl immer vorne steht. Die Zahlen im \lstinline|Dequeue| werden von links nach rechts immer kleiner - die Zahlen links sind also immer größer als die Zahlen rechts. Wenn wir also das Maximum haben wollen, dann greifen wir immer auf die erste Zahl im \lstinline|Dequeue|. Falls die Zahl außerhalb des Arrays rausgeht, dann löschen wir diese Zahl von der Spitze. Damit wir leichter wissen können, welche Zahl aus dem Fenster rausgeht, speichern wir daher nicht den Wert der Zahl, sondern den Index der Zahl.

Wir benutzen nachfolgend dieselbe Zahlenfolge. Diesmal habe ich noch die Indexe hinzugefügt.

	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index: & 0 & 1 & 2 & 3 & 4 & 5\\ 
		\hline
		Value: & 7 & 6 & 2 & 4 & 1 & 7\\
		\hline
	\end{tabular}


Wenn wir obiges Beispiel nehmen, dann würde der Ablauf wie folg aussehen:
\begin{enumerate} 
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index: & \cellcolor{yellow!25}0 & 1 & 2 & 3 & 4 & 5\\ 
		\hline
		Value: & \cellcolor{blue!25}7 & 6 & 2 & 4 & 1 & 7\\
		\hline
	\end{tabular}
		
	Erste Zahl ist 7. Weil die \lstinline|Dequeue| noch leer ist, pushen wir das erste Index sie in unsere \lstinline|Dequeue| rein	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		0 \\
		\hline
	\end{tabular} 
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index: & \cellcolor{yellow!25}0 & \cellcolor{yellow!25}1 & 2 & 3 & 4 & 5\\ 
		\hline
		Value: & \cellcolor{blue!25}7 & \cellcolor{blue!25}6 & 2 & 4 & 1 & 7\\
		\hline
	\end{tabular}
		
	Die 6 ist kleiner (man erinnert sich: Wir wollen in der \lstinline|Dequeue| die Zahlen der kleiner nach speichern) als das aktuelle max und wir pushen sie ins \lstinline|Dequeue|: 	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		0 & 1 \\
		\hline
	\end{tabular} 
	
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index: & \cellcolor{yellow!25}0 & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}2 & 3 & 4 & 5\\ 
		\hline
		Value: & \cellcolor{blue!25}7 & \cellcolor{blue!25}6 & \cellcolor{blue!25}2 & 4 & 1 & 7\\
		\hline
	\end{tabular}
	
	Die 2 ist kleiner als die 6. Dadurch pushen wir auch sie in unsere \lstinline|Dequeue|
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		0 & 1 & 2\\
		\hline
	\end{tabular}.

Damit haben wir die Fensterbreite erreicht. Jetzt müssen wir aufpassen, wann eine Zahl aus dem Fenster rausrutscht. Falls diese Zahl nicht mehr im Fenster ist, müssen wir auch dessen Index rauslöschen.
	
	\item Schritt
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index: & 0 & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}2 & \cellcolor{yellow!25}3 & 4 & 5\\ 
		\hline
		Value: & 7 & \cellcolor{blue!25}6 & \cellcolor{blue!25}2 & \cellcolor{blue!25}4 & 1 & 7\\
		\hline
	\end{tabular}
	Die 4 ist in das Fenster reingekommen. Die 4 ist aber größer als die 2. Daher löschen wir sie (bzw. dessen Index). Wir überprüfen, ob vor der Zahl 2 noch eine Zahl ist, die kleiner ist als die 4. Dies ist nicht der Fall. Wäre es aber der Fall, so müssten wir auch diesen Index löschen. Wir müssten nämlich so lange die Indexe löschen, bis der \lstinline|Dequeue| die Struktur der Gestalt hat, dass sie absteigend ist, also vorne die großen Zahlen, hinten die kleinen. Daher löschen wir nur die Index der Zahl 2 aus der \lstinline|Dequeue| und fügen den Index der Zahl 4 hinzu: 
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		0 & 1 & 3\\
		\hline
	\end{tabular}.
	
	Es passiert an dieser Stelle aber noch mehr: Die 7 (Index Stelle 0) ist aus dem Fenster gerutscht. Das ist deshalb bemerkenswert, weil die 7 bisher das Maximum war und damit an erster Stelle unserer \lstinline|Dequeue| steht. Weil die Zahl 7 jetzt raus ist, löschen wir auch die den Index 0 aus unserem \lstinline|Dequeu|
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		1 & 3\\
		\hline
	\end{tabular}.
	Dadurch steht der Index 1 an erster Stelle unserer \lstinline|Dequeue|. D.h. die 6 ist das Maximum an dieser Stelle.
\end{enumerate}

Ich könnte das jetzt weiter fortführen, aber ich glaube das Prinzip sollte mittlerweile klar sein.

Unter der Berücksichtigung der "typischen Fehler" und den Ansatz mit der \lstinline|Dequeue|, schaut die Implementierung wie folgt aus:

\begin{lstlisting}[caption=My Javascript Example]
const findMaxSlidingWindow = function(arr, windowSize) {  
	// early exit
	if(arr.length == 0 || windowSize > arr.length) {
		return;
	}
	let result = [];
	let dequeue = [];
	const dequeueIsNotEmpty = () => dequeue.length > 0;
	const currentElementLargerThanLastDequeueElement = currentEl => currentEl >= arr[dequeue[dequeue.length - 1]]
	
	// setup for first step
	for (let i = 0; i < windowSize; i++) {
		// remove all elements that are smaller than the current element
		while (dequeueIsNotEmpty() 
		&& currentElementLargerThanLastDequeueElement(arr[i])) {
			dequeue.pop();
		}
		
		dequeue.push(i);
	}
	
	result.push(arr[dequeue[0]])
	
	// remaining steps  
	for (let i = windowSize; i < arr.length; i++) {
		// remove all elements that are smaller than the current element
		while (dequeueIsNotEmpty() 
		&& currentElementLargerThanLastDequeueElement(arr[i])) {
			dequeue.pop();
		}
		
		// if number falls out from the window, we have to delete it from the dequeue
		if (dequeueIsNotEmpty() && (dequeue[0] < i - (windowSize - 1))) {
			dequeue.shift();
		}
		
		dequeue.push(i);
		result.push(arr[dequeue[0]]);
	}
	
	return result;
};
\end{lstlisting}

Eine alternative Lösung ist es, einen \lstinline|Heap()| zu verwenden.
\medskip

\section{Die kleinste gemeinsame Zahl in verschiedenen Arrays}
\begin{examplei}
	Gegeben sind drei Arrays, die ganze Zahlen enthalten. Die Zahlen sind aufsteigend sortiert. Gesucht ist die kleinste Zahl, die in allen diesen Arrays vorkommt. Falls es keine gemeinsame Zahl gibt, dann soll \lstinline|-1| zurückgegeben werden.
	
	Beispiel:
	Gegeben sind folgende drei Arrays und es wird nach der kleinsten Zahl gesucht, die alle der gegebenen Arrays gemeinsam haben.
	

	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		1 & \cellcolor{yellow!25}7 & 11 & 15 & 26 \\
		\hline
	\end{tabular}

	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		3 & 4 & 5 & 6 & \cellcolor{yellow!25}7 & 14 & 16 & 69 \\
		\hline
	\end{tabular}

	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		2 & 5 & 6 & \cellcolor{yellow!25}7 \\
		\hline
	\end{tabular}

	Die kleinste Zahl, die in allen der obigen Arrays vorkommt ist die \lstinline|7|.
	
\end{examplei}
{\bf Stichwörter:} Array, Suche, Zeiger

\paragraph{Vorgehensweise}
\begin{enumerate}
	\item Wir erstellen drei Zeiger - eines für jedes Array. Wir fangen bei \lstinline|0| an, da die Arrays aufsteigend sortiert sind.
	\item Danach gehen wir in eine Schleife rein. Die Schleife soll solange ausgeführt werden, bis eines der Zeiger über das Ende ihres jeweiligen Arrays erreicht. Denn wenn der Zeiger über dem Ende des Arrays erreicht ohne, dass wir eine gemeinsame Zahl gefunden haben, dann können wir davon ausgehen, dass es keine kleinste gemeinsame Zahl unter allen Arrays existiert.
	\item Wir greifen zuerst das Element, auf das der Zeiger des ersten Array momentan zeigt. In der ersten Iteration ist es das erste Element. Innerhalb der äußeren Schleife haben wir noch eine zweite Schleife, die den zweiten Array durchläuft und nach dem aktuellen Wert im ersten Array durchsucht. 
	\item Wird das Element gefunden wird ein Flag gesetzt und die innere Schleife unterbrochen. Der Zeiger des zweiten Arrays wird dann auf den letzten Wert der Laufvariable gesetzt, damit er bei der nächsten Iteration der äußeren Schleife wieder dort fortsetzen kann, wo er aufgehört hat.
	\item Danach kommt eine zweite innere Schleife. Diese wird aber nur durchlaufen, wenn in der ersten inneren Schleife ein gemeinsamer Wert zwischen dem ersten und dem zweiten Array gefunden wurde, also wenn der Flag gesetzt wurde.
	\item Falls der Flag gesetzt wurde, wird die zweite innere Schleife durchlaufen. Innerhalb dieser Schleife ist es analog zur ersten inneren Schleifen mit dem Unterschied, dass, wenn ein übereinstimmender Wert gefunden wurde, dann wird dieser Wert sofort zurückgegeben, denn damit wurde ein gemeinsamer Wert unter allen drei Arrays gefunden. Falls nicht, also falls ein Wert gefunden wurde, der größer ist als der aktuelle Vergleichswert, dann verläuft es genauso wie in der ersten inneren Schleife: Der Zeiger wird auf dem aktuellen Laufindex gesetzt und die Schleife wird anschließend unterbrochen.
	\item Am Ende der äußeren Schleife wird der Zeiger des ersten Arrays um eins erhöht und die nächste Iteration der äußeren Schleife wird durchlaufen.
	\item Falls die äußere Schleife komplett durchlaufen wird und kein übereinstimmendes Element gefunden wurde, dann wird \lstinline|-1| zurückgegeben.	
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]
let findLeastCommonNumber = function(a, b, c) {
	let aPointer = 0;
	let bPointer = 0;
	let cPointer = 0;
	
	while (aPointer < a.length ||
		   bPointer < b.length || 
		   cPointer < c.length) {
		const aValue = a[aPointer];
		let bFound = false;
		for (let i = bPointer; i < b.length; i++) {
			if (b[i] === aValue) {
				bPointer = i;
				bFound = true;
				break;
			}
			if (b[i] > aValue) {
				bPointer = i;
				break;
			}
		}
		if (bFound) {
			for (let i = cPointer; i < c.length; i++) {
				if (c[i] === aValue) {
					return a[aPointer];
				}
				if (c[i] > aValue) {
					cPointer = i;
					break;
				}
			}
		}
		aPointer++;
	}
	return -1;
};
\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item Kein early exit verwendet
	
	Man hätte hier überprüfen können, ob mindestens eines der Arrays leer ist und gegebenfalls sofort \lstinline|-1| zurückgeben können.
	
	\item Relativ komplex
	
	Durch die verschachtelte Schleife und die verschachtelten \lstinline|if| Abfragen ist der Code etwas komplexer als notwendig und somit vergleichsweise schwerer verständlich als die nachfolgende Lösung. Generell sollte man versuchen die Verschachtelungen so gering wie möglich zu halten. Dies erhöht die Verständlichkeit und damit auch die Wartbarkeit.
	
\end{itemize}

\paragraph{Lösung} Die obige Lösung liefert ebenfalls das richtige Ergebnis. Nachfolgend aber eine etwas leichter verständliche Lösung.
\begin{enumerate} 
	\item Wir können hier einen early exit anwenden. Denn wenn eines der Array leer ist, dann können wir schlussfolgern, dass es keinen gemeinsamen Wert unter allen drei Arrays gibt. Wir geben in diesem Fall also \lstinline|-1| 
	\item Wir erstellen wieder drei Zeiger - eines für jedes Array. Wir fangen auch hier bei \lstinline|0| an.
	\item danach gehen wir in eine Schleife rein. Bis hier ist noch alles gleich. Im Gegensatz zum Erstversuch aber, überprüfen wir in der Schleife, ob alle Zeiger noch kleiner sind als die Länge der jeweiligen Arrays. Falls eines der Zeiger über das Ende des Arrays erreicht hat, dann terminiert die Schleife. Diese Änderung hat damit zu tun, was wir später im Schleifenrumpf machen werden.
	\item Das erste, was wir im Schleifenrumpf überprüfen ist, ob die Werte, auf die alle Zeiger momentan zeigen alle gleich sind. Falls dem so ist, geben wir den Wert zurück. 
	\item Im nächsten Schritt überprüfen wir 
	\item Wir auch im dritten Array dieselbe Zahl gefunden, dann geben wir sie zurück. Ansonsten erhöhen wir den Zeiger des ersten Arrays und führen die Schritte ab \lstinline|3| wieder aus.
	\item Dies wiederholen wir bis wir 
	
	Am Ende geben wir das Resultat-Array zurück
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]
let find_least_common_number = function(a, b, c) {
	if (a.length === 0 ||
		b.length === 0 ||
		c.length === 0) {
		return -1;
	}
	let i = 0;
	let j = 0;
	let k = 0;

	while (i < a.length
	&& j < b.length 
	&& k < c.length) {
	
		// Finding the smallest common number
		if (a[i] === b[j]
		&& b[j] === c[k]) {
			return a[i];
		}
		
		// Let's increment the iterator
		// for the smallest value.
		
		if (a[i] <= b[j]
		&& a[i] <= c[k]) {
			i++;
		} else if (b[j] <= a[i]
		&& b[j] <= c[k]) {
			j++;
		} else if (c[k] <= a[i]
		&& c[k] <= b[j]) {
			k++;
		}	
	}
	
	return -1;
};
\end{lstlisting}

Aber auch diese Lösung ist nicht perfekt. Ein Nachteil ist, dass diese Lösung, im Gegensatz zum Erstversuch, weniger skalierbarer ist. Angenommen die Anforderungen ändern sich und 

\section{Array verschieben}
\begin{examplei}
	Gegeben ist ein langes Array und eine ganze Zahl. Die Zahl steht dafür um wieviel das Array verschoben wird. Das Vorzeichen der Zahl steht für die Richtung in welcher das Array verschoben wird. Eine Zahl größer als \lstinline|0| heißt verschieben nach rechts. Ein Zahl kleiner als \lstinline|0| heißt verschieben nach links. Gesucht ist das Resultat nach dem Verschieben.
	
	Beispiel:
	Gegeben ist folgender Array und eine Zahl \lstinline|4|. 	
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		3 & 23 & -31 & 47 & -65 & 69 \\
		\hline
	\end{tabular}

	Nach dem Verschieben um 4 nach rechts ist das erwartete Ergebnis:
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		\cellcolor{yellow!25}-31 & \cellcolor{yellow!25}47 & \cellcolor{yellow!25}-65 & \cellcolor{yellow!25}69 & 3 & 23 \\
		\hline
	\end{tabular}
	
	Nehmen wir dasselbe Array. Verschieben wir das Array um \lstinline|-1|, dann schaut das erwartete Ergebnis folgendermaßen aus:
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		23 & -31 & 47 & -65 & 69 & \cellcolor{yellow!25}3 \\
		\hline
	\end{tabular}
	
\end{examplei}
{\bf Stichwörter:} Array, Zeiger, Pointer

\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item Wir teilen das Problem in drei Fälle: 
	\begin{itemize} 
		\item wenn die Zahl gleich 0 oder gleich die Arraylänge ist
		\item wenn die Zahl größer 0 ist 
		\item wenn die Zahl kleiner 0 ist
	\end{itemize}

	\item Wenn die Zahl gleich 0 oder gleich der Arraylänge ist, dann wissen wir, dass wir die Element nicht verschieben müssen. In diesem Fall können wir das Original Array ohne Änderung zurückgeben

	\item Wenn die Zahl größer als 0 ist, dann will ich das Array nach rechts verschieben. Alle Elemente werden also um \lstinline|n| Stellen nach rechts verschoben. Am Ende der Operation sollen die \lstinline|n| letzten Elemente vorne stehen. Dazu kopiere ich mir die ersten \lstinline|Array.length - n| Elemente und hänge sie hinten an. Danach lösche ich die ersten \lstinline|Array.length - n| Elemente. Dadurch stehen die letzten \lstinline|n| Elemente vorne am Array.
	
	\item Wenn die Zahl kleiner als 0 ist, heißt das, dass ich die Elemente nach links verschiebe. Alle Elemente werden also um den Betrag von \lstinline|n| Stellen nach links verschoben. Wir bilden also zuerst den Betrag von \lstinline|n|. Dann hängen wir die ersten \lstinline|n|\footnote{Ab dieser Stelle kennzeichnet \lstinline|n| den Betrag von \lstinline|n|. \lstinline|n| ist also immer positiv} Elemente werden hinten angehängt. Dazu kopieren wir uns die ersten \lstinline|n| Elemente und hängen sie hinten an. Danach löschen wir die ersten \lstinline|n| Elemente wieder.
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]
let rotate_array = function(arr, n) {
	if (n === 0 || n === arr.length) {
		return arr;
	}
	if (n > 0) {
		const len = arr.length;
		for (let i = 0; i < len - n; i++) {
			arr.push(arr[i]);
		}
		arr.splice(0, len - n);
		return arr;    
	}
	if (n < 0) {
		const absN = Math.abs(n);
		for (let i = 0; i < absN; i++) {
			arr.push(arr[i]);
		}
		arr.splice(0, absN);
		return arr;
	}
};
\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item Zu lang bzw. sehr viel Wiederholungen
	
	Der Code ist länger als nötig. Dies liegt daran, dass bestimmte Codestellen wiederholt werden, wie z.B. \lstinline|return arr;| oder die beiden \lstinline|for| Schleifen. Auch ist die Abfrage, ob \lstinline|n === arr.length| überflüssig, denn für den Fall, dass \lstinline|n| gleich der Arraylänge ist, dann kommt es in den Fall \lstinline|(n > 0)| rein und in der \lstinline|for| Schleife steht dann
	
	\lstinline|(let i = 0; i < 0; i++)|. 
	
	Die Schleife wird also gar nicht erst ausgeführt. Weiter unten würde dann dieser Ausdruck stehen: 
	
	\lstinline|arr.splice(0, 0);|
	
	Das original Array bleibt also unberührt.
	
	Wenn man die \lstinline|return arr;| aus den \lstinline|if| Ausdrücken herauszieht und es ganz unten an der Funktion anhängt, kann man die ersten drei Zeilen löschen ohne dass die Ausgabe des Programms verändert wird:
	
	\begin{lstlisting}[caption=My Javascript Example]
	if (n > 0) {
		const len = arr.length;
		for (let i = 0; i < len - n; i++) {
			arr.push(arr[i]);
		}
		arr.splice(0, len - n);
	}
	if (n < 0) {
		const absN = Math.abs(n);
		for (let i = 0; i < absN; i++) {
			arr.push(arr[i]);
		}
		arr.splice(0, absN);
	}
	return arr;
	\end{lstlisting} 
	
	\item Ineffizient
	
	Angenommen man will will das Array um \lstinline|1| nach rechts schieben, dann muss man man \lstinline|Array.length - 1| Elemente kopieren und diese hinten anhängen und dann dieselbe Anzahl vorne löschen. Wie man sich vorstellen kann ist das bei langen Arrays ineffizient.
	
	\item Wenig intuitiv
	
	Code wird öfter gelesen als dass sie geschrieben wird. Daher ist es wichtig, dass Code für andere Entwickler leicht verständlich ist. In diesem Fall ist die Berechnung \lstinline|Array.length - n| nicht sofort verständlich.
	 
\end{itemize}

Eine anderer Ansatz:

Wir wissen, dass, wenn \lstinline|n| positiv ist, dann verschiebt sich das Array um \lstinline|n| Stellen nach rechts. Das Element an der \lstinline|0|ten Stelle befindet sich nach dem Verschieben an der \lstinline|n|ten Stelle rechts. Die nun freien Stellen links von dem ursprünglich ersten Element, werden mit den Elementen aufgefüllt, die ganz rechts sind. Wir schneiden also vor dem \lstinline|Array.length - n|-ten Element (\lstinline|0| basierter Index) ab und hängen den rechten Teil an das Linke.

Wenn \lstinline|n| negativ ist, dann verschiebt sich das Array um \lstinline|n| Stellen nach links. Die dadurch freien Stellen rechts werden mit den Elementen ganz links aufgefüllt. Das Element an der ursprünglich \lstinline|0|ten Stelle befindet sich nach dem Verschieben an der \lstinline|Array.length + n|ten \footnote{Wir addieren hier weil \lstinline|n| negativ ist} Stelle (\lstinline|0| basierter Index). Wir schneiden also vor dem \lstinline|Array.length - (Array.length + n)|-ten Element ab und hängen den linken Teil an das Rechte. 

Wir können das Verschieben des Arrays also erreichen, indem wir das Array an einer bestimmten Stelle "zerschneiden" und den zerschnittenen Teil entweder links oder rechts anhängen - abhängig davon, ob die Zahl größer oder kleiner \lstinline|0| ist. 

\begin{enumerate} 
	\item Wir nutzen die \lstinline|splice()| Funktion, um das Original Array ab bestimmten Elementen zu zerteilen. \lstinline|splice()| mit einem Argument schneidet das Array an einer bestimmten Stelle und gibt den entfernten Teil als Ergebnis zurück. Z.B. \lstinline|splice(3)| bedeutet, dass wir das ursprüngliche Array vor dem \lstinline|3|-ten Element zerschneiden und den entfernten Teil als Ergebnis zurückgeben.
	
	Wie oben erklärt findet das Zerschneiden bei einer positiven Zahl am (inklusive) \lstinline|Array.length - n|-ten Element bis zum Ende. Wir zählen die Stellen also von rechts nach links. Wenn wir ein Minus davor setzen zählt \lstinline|splice()| von rechts nach links. Statt \lstinline|splice(Array.length - n)| können wir also auch schreiben \lstinline|splice(-1 * n)|. Bei einer negativen Zahl am (inklusive) \lstinline|Array.length - (Array.length + n)|-ten Element bis zum Ende des Arrays. Diesen Ausdruck können wir (für negative Zahlen) auch schreiben als \lstinline|-n|. In beiden Fällen können wir also \lstinline|splice(-1 * n)| schreiben.
	\item Wir speichern den entfernten Array-Teil, um ihn später auf der anderen Seite des originalen Arrays anzuhängen.
	\item Wir wollen die Zahlen aus dem entfernten Array-Teil nun am ursprünglichen Array anhängen. Wir nehmen die einzelnen Elemente des entfernten Array-Teils und hängen sie einzeln vorne am Ursprungsarray an. Wenn wir die Elemente aber vorne am Array anhängen wollen, können wir aber nicht das erste Element nehmen, sondern müssen mit dem letzten Element anfangen und uns zum ersten Element vorarbeiten. Ansonsten würden wir die Elemente in umgekehrter Reihenfolge anhängen. Daher drehen wir das Array mit Hilfe der \lstinline|reverse()| Funktion um und lassen dann eine \lstinline|forEach()| Funktion über das Array iterieren. 
	
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]
let rotate_array = function(arr, n) {
	const rem = arr.splice(-1 * n);
	rem.reverse().forEach(x => arr.unshift(x));    

	return arr;
};
\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item \lstinline|unshift()| ineffizient
	
	Die Verwendung der Funktion \lstinline|unshift()| ist ineffizient, v.a. bei langen Arrays. Denn die einzelnen Elemente müssen alle um einen Index nach hinten verschoben werden. Bei kleinen Arrays ist die Performanceeinbuße vernachlässigbar. Bei langen Arrays ist es besser die \lstinline|push()| Funktion zu verwenden.
	
	\item \lstinline|reverse()| unnötig
	
	Die Tatsache, dass man beim Array vom letzten Element anfangen muss ist in diesem Fall richtig, da wir die Elemente von vorne anhängen (mit Hilfe von \lstinline|unshift()|). Würden wir von hinten anhängen und eine Schleife benutzen, die vom ersten bis zum letzen Index läuft, bräuchten wir das Array nicht umzudrehen. Jedoch ist es hier unnötig das Array mit der \lstinline|reverse()| Funktion umzukehren. Man kann auch die Schleife von hinten anfangen lassen. Einfach und effizienter wäre es eine \lstinline|for| Schleife zu verwenden, die beim höchsten Index (also dem letzten Element) anfängt und sich dann vorarbeitet zum niedrigsten Index (also dem ersten Element).
	
\end{itemize}

Die obige Lösung liefert das korrekte Ergebnis. Ist bei langen Arrays jedoch ineffizient.

\paragraph{Lösung} Durch die korrekte Verwendung der \lstinline|splice()| Funktion und von ES6+ Syntax, den Rest/Spread Operator, können wir das Verschieben des Arrays intuitiv veranschaulichen.

\begin{lstlisting}[caption=My Javascript Example]
let rotate_array = function(arr, n) {
	const rem = arr.splice(-1 * n);
	return [...rem, ...arr];
};
\end{lstlisting}

\section{Niedrigster/höchster Index}
\begin{examplei}
	Gegeben ist ein sortiertes Array von ganzen Zahlen. Gib den niedrigsten und höchsten Index einer Zahl zurück. Falls die Zahl nicht existiert, dann gib \lstinline|-1| zurück. Das Array kann beliebig lang sein und eine beliebige Anzahl an Duplikaten enthalten.
	
	Beispiel:
	Gegeben ist folgendes Array\footnote{Die farbliche Markierung ist nur zur Verdeutlichung wo der niedrigste und höchste Index anfängt bzw. aufhört.} und eine Zahl \lstinline|3|. 	
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		Index & 0 & 1 & \cellcolor{yellow!25}2 & \cellcolor{yellow!25}3 & \cellcolor{yellow!25}4 & \cellcolor{yellow!25}5 & \cellcolor{yellow!25}6 & \cellcolor{yellow!25}7 & 8 & 9 & 10\\
		\hline
		Value & 1 & 1 & \cellcolor{blue!25}3 & \cellcolor{blue!25}3 & \cellcolor{blue!25}3 & \cellcolor{blue!25}3 & \cellcolor{blue!25}3 & \cellcolor{blue!25}3 & 11 & 13 & 17\\
		\hline
	\end{tabular}

	Der niedrigste Index ist \lstinline|2| und der höchste Index ist \lstinline|7|
\end{examplei}
{\bf Stichwörter:} Array, Zeiger, Pointer

\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item Wir erstellen zwei Zeiger. Einen
	\item Iterieren, bis wir das erste Mal die Zahl sehen
	\item Iterieren so lange, bis wir das letzte Mal die Zahl sehen
	\item Rückgabe des Wertes
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]

\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item 
\end{itemize}

\paragraph{Lösung}
text....

\begin{lstlisting}[caption=My Javascript Example]

\end{lstlisting}

%==========================
\section{TEST}
\begin{examplei}
	Text...
	
	Beispiel:
	Gegeben ist folgender Array mit einer Fensterbreite von \lstinline|4|. 	
	
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|} 
		\hline
		3 & 23 & -31 & 47 & -65 & 69 \\
		\hline
	\end{tabular}
	Das Fenster bewegt sich nun von links nach rechts und enthält folgende Zahlen:
	\begin{enumerate}
		\item Schritt	

		Das Maximum ist wieder \lstinline|69|
	\end{enumerate}
		
\end{examplei}
{\bf Stichwörter:} Array, Suche, Sliding Window, Zeiger, Pointer, Dequeue

\paragraph{Vorgehensweise}
\begin{enumerate} 
	\item 
\end{enumerate}

\begin{lstlisting}[caption=My Javascript Example]

\end{lstlisting}

\paragraph{Typische Fehler}
\begin{itemize} 
	\item 
\end{itemize}

\paragraph{Lösung}
text....

\begin{lstlisting}[caption=My Javascript Example]

\end{lstlisting}

Eine alternative Lösung ist es, einen \lstinline|Heap()| zu verwenden.
\begin{lstlisting}[caption=My Javascript Example]
// test...

\end{lstlisting}


\end{document}